/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from CombinedDomains.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include <inspector/InspectorProtocolTypes.h>
#include <wtf/Assertions.h>

namespace Inspector {



namespace Protocol {

// Forward declarations.
namespace ApplicationCache {
class ApplicationCacheResource;
class ApplicationCache;
class FrameWithManifest;
} // ApplicationCache

namespace CSS {
class CSSStyleId;
class CSSRuleId;
class PseudoIdMatches;
class InheritedStyleEntry;
class RuleMatch;
class CSSSelector;
class SelectorList;
class CSSStyleAttribute;
class CSSStyleSheetHeader;
class CSSStyleSheetBody;
class CSSRule;
class SourceRange;
class ShorthandEntry;
class CSSPropertyInfo;
class CSSComputedStyleProperty;
class CSSStyle;
class CSSProperty;
class CSSMedia;
enum class StyleSheetOrigin;
enum class CSSPropertyStatus;
} // CSS

namespace Canvas {
class ContextAttributes;
class Canvas;
enum class ContextType;
enum class ShaderType;
} // Canvas

namespace Console {
class Channel;
class ConsoleMessage;
class CallFrame;
class StackTrace;
enum class ChannelSource;
enum class ChannelLevel;
} // Console

namespace DOM {
class Node;
class EventListener;
class AccessibilityProperties;
class RGBAColor;
class HighlightConfig;
enum class PseudoType;
enum class ShadowRootType;
enum class CustomElementState;
enum class LiveRegionRelevant;
} // DOM

namespace DOMDebugger {
enum class DOMBreakpointType;
} // DOMDebugger

namespace DOMStorage {
class StorageId;
} // DOMStorage

namespace Database {
class Database;
class Error;
} // Database

namespace Debugger {
class Location;
class BreakpointAction;
class BreakpointOptions;
class FunctionDetails;
class CallFrame;
class Scope;
class ProbeSample;
class AssertPauseReason;
class BreakpointPauseReason;
class CSPViolationPauseReason;
} // Debugger

namespace GenericTypes {
class SearchMatch;
} // GenericTypes

namespace Heap {
class GarbageCollection;
} // Heap

#if ENABLE(INDEXED_DATABASE)
namespace IndexedDB {
class DatabaseWithObjectStores;
class ObjectStore;
class ObjectStoreIndex;
class Key;
class KeyRange;
class DataEntry;
class KeyPath;
} // IndexedDB
#endif // ENABLE(INDEXED_DATABASE)

namespace LayerTree {
class IntRect;
class Layer;
class CompositingReasons;
} // LayerTree

#if ENABLE(RESOURCE_USAGE)
namespace Memory {
class Event;
class CategoryData;
} // Memory
#endif // ENABLE(RESOURCE_USAGE)

namespace Network {
class Headers;
class ResourceTiming;
class Request;
class Response;
class Metrics;
class WebSocketRequest;
class WebSocketResponse;
class WebSocketFrame;
class CachedResource;
class Initiator;
} // Network

namespace OverlayTypes {
class Point;
class Size;
class Rect;
class ShapeOutsideData;
class ElementData;
class FragmentHighlightData;
class NodeHighlightData;
class OverlayConfiguration;
} // OverlayTypes

namespace Page {
class Frame;
class FrameResource;
class FrameResourceTree;
class SearchResult;
class Cookie;
enum class ResourceType;
enum class CoordinateSystem;
} // Page

namespace Recording {
class InitialState;
class Frame;
class Recording;
enum class Type;
} // Recording

namespace Runtime {
class RemoteObject;
class ObjectPreview;
class PropertyPreview;
class EntryPreview;
class CollectionEntry;
class PropertyDescriptor;
class InternalPropertyDescriptor;
class CallArgument;
class ExecutionContextDescription;
class ErrorRange;
class StructureDescription;
class TypeSet;
class TypeDescription;
class TypeLocation;
class BasicBlock;
enum class SyntaxErrorType;
} // Runtime

namespace ScriptProfiler {
class Event;
class ExpressionLocation;
class StackFrame;
class StackTrace;
class Samples;
enum class EventType;
} // ScriptProfiler

namespace ServiceWorker {
class InitializationInfo;
} // ServiceWorker

namespace Timeline {
class TimelineEvent;
enum class EventType;
enum class Instrument;
} // Timeline
// End of forward declarations.


// Typedefs.
namespace CSS {
typedef String StyleSheetId;
} // CSS

namespace Canvas {
/* Unique canvas identifier. */
typedef String CanvasId;
/* Unique shader program identifier. */
typedef String ProgramId;
} // Canvas

namespace DOM {
/* Unique DOM node identifier. */
typedef int NodeId;
/* Unique DOM node identifier used to reference a node that may not have been pushed to the front-end. */
typedef int BackendNodeId;
/* Unique event listener identifier. */
typedef int EventListenerId;
/* An array of quad vertices, x immediately followed by y for each point, points clock-wise. */
typedef Inspector::Protocol::Array<double> Quad;
} // DOM

namespace DOMStorage {
/* DOM Storage item. */
typedef Inspector::Protocol::Array<String> Item;
} // DOMStorage

namespace Database {
/* Unique identifier of Database object. */
typedef String DatabaseId;
} // Database

namespace Debugger {
/* Breakpoint identifier. */
typedef String BreakpointId;
/* Breakpoint action identifier. */
typedef int BreakpointActionIdentifier;
/* Unique script identifier. */
typedef String ScriptId;
/* Call frame identifier. */
typedef String CallFrameId;
} // Debugger

namespace Heap {
/* JavaScriptCore HeapSnapshot JSON data. */
typedef String HeapSnapshotData;
} // Heap

namespace LayerTree {
/* Unique RenderLayer identifier. */
typedef String LayerId;
/* Unique PseudoElement identifier. */
typedef String PseudoElementId;
} // LayerTree

namespace Network {
/* Unique loader identifier. */
typedef String LoaderId;
/* Unique frame identifier. */
typedef String FrameId;
/* Unique request identifier. */
typedef String RequestId;
/* Elapsed seconds since frontend connected. */
typedef double Timestamp;
/* Number of seconds since epoch. */
typedef double Walltime;
} // Network

namespace OverlayTypes {
/* A quad is a collection of 4 points. When initialized from a rect, the points are in clockwise order from top left. */
typedef Inspector::Protocol::Array<Inspector::Protocol::OverlayTypes::Point> Quad;
/* A vector path described using SVG path syntax. */
typedef Inspector::Protocol::Array<JSON::Value> DisplayPath;
} // OverlayTypes

namespace Runtime {
/* Unique object identifier. */
typedef String RemoteObjectId;
/* Id of an execution context. */
typedef int ExecutionContextId;
} // Runtime
// End of typedefs.

namespace InspectorHelpers {

JS_EXPORT_PRIVATE String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

} // namespace InspectorHelpers

namespace ApplicationCache {
/* Detailed application cache resource information. */
class ApplicationCacheResource : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        SizeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | SizeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ApplicationCacheResource*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ApplicationCacheResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setInteger(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), value);
            return castState<TypeSet>();
        }

        Ref<ApplicationCacheResource> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ApplicationCacheResource) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ApplicationCacheResource>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ApplicationCacheResource> result = ApplicationCacheResource::create()
     *     .setUrl(...)
     *     .setSize(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Detailed application cache information. */
class ApplicationCache : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ManifestURLSet = 1 << 0,
        SizeSet = 1 << 1,
        CreationTimeSet = 1 << 2,
        UpdateTimeSet = 1 << 3,
        ResourcesSet = 1 << 4,
        AllFieldsSet = (ManifestURLSet | SizeSet | CreationTimeSet | UpdateTimeSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ApplicationCache*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ApplicationCache;
    public:

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString(ASCIILiteral("manifestURL"), value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | SizeSet>& setSize(double value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setDouble(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | CreationTimeSet>& setCreationTime(double value)
        {
            COMPILE_ASSERT(!(STATE & CreationTimeSet), property_creationTime_already_set);
            m_result->setDouble(ASCIILiteral("creationTime"), value);
            return castState<CreationTimeSet>();
        }

        Builder<STATE | UpdateTimeSet>& setUpdateTime(double value)
        {
            COMPILE_ASSERT(!(STATE & UpdateTimeSet), property_updateTime_already_set);
            m_result->setDouble(ASCIILiteral("updateTime"), value);
            return castState<UpdateTimeSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::ApplicationCache::ApplicationCacheResource>> value)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setArray(ASCIILiteral("resources"), value);
            return castState<ResourcesSet>();
        }

        Ref<ApplicationCache> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ApplicationCache) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ApplicationCache>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ApplicationCache> result = ApplicationCache::create()
     *     .setManifestURL(...)
     *     .setSize(...)
     *     .setCreationTime(...)
     *     .setUpdateTime(...)
     *     .setResources(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Frame identifier - manifest URL pair. */
class FrameWithManifest : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FrameIdSet = 1 << 0,
        ManifestURLSet = 1 << 1,
        StatusSet = 1 << 2,
        AllFieldsSet = (FrameIdSet | ManifestURLSet | StatusSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FrameWithManifest*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FrameWithManifest;
    public:

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::Protocol::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | ManifestURLSet>& setManifestURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ManifestURLSet), property_manifestURL_already_set);
            m_result->setString(ASCIILiteral("manifestURL"), value);
            return castState<ManifestURLSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setInteger(ASCIILiteral("status"), value);
            return castState<StatusSet>();
        }

        Ref<FrameWithManifest> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameWithManifest) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<FrameWithManifest>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FrameWithManifest> result = FrameWithManifest::create()
     *     .setFrameId(...)
     *     .setManifestURL(...)
     *     .setStatus(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // ApplicationCache

namespace CSS {
/* This object identifies a CSS style in a unique way. */
class CSSStyleId : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleId*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::Protocol::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setInteger(ASCIILiteral("ordinal"), value);
            return castState<OrdinalSet>();
        }

        Ref<CSSStyleId> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleId) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSStyleId>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleId> result = CSSStyleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Stylesheet type: "user" for user stylesheets, "user-agent" for user-agent stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via inspector" rules), "regular" for regular stylesheets. */
enum class StyleSheetOrigin {
    User = 0,
    UserAgent = 1,
    Inspector = 2,
    Regular = 3,
}; // enum class StyleSheetOrigin
/* This object identifies a CSS rule in a unique way. */
class CSSRuleId : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        OrdinalSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | OrdinalSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSRuleId*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSRuleId;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::Protocol::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | OrdinalSet>& setOrdinal(int value)
        {
            COMPILE_ASSERT(!(STATE & OrdinalSet), property_ordinal_already_set);
            m_result->setInteger(ASCIILiteral("ordinal"), value);
            return castState<OrdinalSet>();
        }

        Ref<CSSRuleId> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSRuleId) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSRuleId>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSRuleId> result = CSSRuleId::create()
     *     .setStyleSheetId(...)
     *     .setOrdinal(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS rule collection for a single pseudo style. */
class PseudoIdMatches : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        PseudoIdSet = 1 << 0,
        MatchesSet = 1 << 1,
        AllFieldsSet = (PseudoIdSet | MatchesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PseudoIdMatches*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class PseudoIdMatches;
    public:

        Builder<STATE | PseudoIdSet>& setPseudoId(int value)
        {
            COMPILE_ASSERT(!(STATE & PseudoIdSet), property_pseudoId_already_set);
            m_result->setInteger(ASCIILiteral("pseudoId"), value);
            return castState<PseudoIdSet>();
        }

        Builder<STATE | MatchesSet>& setMatches(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> value)
        {
            COMPILE_ASSERT(!(STATE & MatchesSet), property_matches_already_set);
            m_result->setArray(ASCIILiteral("matches"), value);
            return castState<MatchesSet>();
        }

        Ref<PseudoIdMatches> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PseudoIdMatches) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<PseudoIdMatches>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PseudoIdMatches> result = PseudoIdMatches::create()
     *     .setPseudoId(...)
     *     .setMatches(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS rule collection for a single pseudo style. */
class InheritedStyleEntry : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MatchedCSSRulesSet = 1 << 0,
        AllFieldsSet = (MatchedCSSRulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InheritedStyleEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InheritedStyleEntry;
    public:

        Builder<STATE | MatchedCSSRulesSet>& setMatchedCSSRules(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> value)
        {
            COMPILE_ASSERT(!(STATE & MatchedCSSRulesSet), property_matchedCSSRules_already_set);
            m_result->setArray(ASCIILiteral("matchedCSSRules"), value);
            return castState<MatchedCSSRulesSet>();
        }

        Ref<InheritedStyleEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InheritedStyleEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<InheritedStyleEntry>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InheritedStyleEntry> result = InheritedStyleEntry::create()
     *     .setMatchedCSSRules(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setInlineStyle(RefPtr<Inspector::Protocol::CSS::CSSStyle> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("inlineStyle"), WTFMove(value));
    }
};

/* Match data for a CSS rule. */
class RuleMatch : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RuleSet = 1 << 0,
        MatchingSelectorsSet = 1 << 1,
        AllFieldsSet = (RuleSet | MatchingSelectorsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RuleMatch*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class RuleMatch;
    public:

        Builder<STATE | RuleSet>& setRule(RefPtr<Inspector::Protocol::CSS::CSSRule> value)
        {
            COMPILE_ASSERT(!(STATE & RuleSet), property_rule_already_set);
            m_result->setObject(ASCIILiteral("rule"), value);
            return castState<RuleSet>();
        }

        Builder<STATE | MatchingSelectorsSet>& setMatchingSelectors(RefPtr<Inspector::Protocol::Array<int>> value)
        {
            COMPILE_ASSERT(!(STATE & MatchingSelectorsSet), property_matchingSelectors_already_set);
            m_result->setArray(ASCIILiteral("matchingSelectors"), value);
            return castState<MatchingSelectorsSet>();
        }

        Ref<RuleMatch> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RuleMatch) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<RuleMatch>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RuleMatch> result = RuleMatch::create()
     *     .setRule(...)
     *     .setMatchingSelectors(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS selector. */
class CSSSelector : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        AllFieldsSet = (TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSSelector*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSSelector;
    public:

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        Ref<CSSSelector> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSSelector) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSSelector>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSSelector> result = CSSSelector::create()
     *     .setText(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSpecificity(RefPtr<Inspector::Protocol::Array<int>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("specificity"), WTFMove(value));
    }

    void setDynamic(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("dynamic"), value);
    }
};

/* Selector list data. */
class SelectorList : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorsSet = 1 << 0,
        TextSet = 1 << 1,
        AllFieldsSet = (SelectorsSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SelectorList*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SelectorList;
    public:

        Builder<STATE | SelectorsSet>& setSelectors(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> value)
        {
            COMPILE_ASSERT(!(STATE & SelectorsSet), property_selectors_already_set);
            m_result->setArray(ASCIILiteral("selectors"), value);
            return castState<SelectorsSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        Ref<SelectorList> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SelectorList) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<SelectorList>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SelectorList> result = SelectorList::create()
     *     .setSelectors(...)
     *     .setText(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRange(RefPtr<Inspector::Protocol::CSS::SourceRange> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("range"), WTFMove(value));
    }
};

/* CSS style information for a DOM style attribute. */
class CSSStyleAttribute : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        StyleSet = 1 << 1,
        AllFieldsSet = (NameSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleAttribute*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleAttribute;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | StyleSet>& setStyle(RefPtr<Inspector::Protocol::CSS::CSSStyle> value)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setObject(ASCIILiteral("style"), value);
            return castState<StyleSet>();
        }

        Ref<CSSStyleAttribute> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleAttribute) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSStyleAttribute>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleAttribute> result = CSSStyleAttribute::create()
     *     .setName(...)
     *     .setStyle(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS stylesheet meta-information. */
class CSSStyleSheetHeader : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        FrameIdSet = 1 << 1,
        SourceURLSet = 1 << 2,
        OriginSet = 1 << 3,
        TitleSet = 1 << 4,
        DisabledSet = 1 << 5,
        IsInlineSet = 1 << 6,
        StartLineSet = 1 << 7,
        StartColumnSet = 1 << 8,
        AllFieldsSet = (StyleSheetIdSet | FrameIdSet | SourceURLSet | OriginSet | TitleSet | DisabledSet | IsInlineSet | StartLineSet | StartColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleSheetHeader*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleSheetHeader;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::Protocol::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::Protocol::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | SourceURLSet>& setSourceURL(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SourceURLSet), property_sourceURL_already_set);
            m_result->setString(ASCIILiteral("sourceURL"), value);
            return castState<SourceURLSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Inspector::Protocol::CSS::StyleSheetOrigin value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString(ASCIILiteral("origin"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | TitleSet>& setTitle(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TitleSet), property_title_already_set);
            m_result->setString(ASCIILiteral("title"), value);
            return castState<TitleSet>();
        }

        Builder<STATE | DisabledSet>& setDisabled(bool value)
        {
            COMPILE_ASSERT(!(STATE & DisabledSet), property_disabled_already_set);
            m_result->setBoolean(ASCIILiteral("disabled"), value);
            return castState<DisabledSet>();
        }

        Builder<STATE | IsInlineSet>& setIsInline(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsInlineSet), property_isInline_already_set);
            m_result->setBoolean(ASCIILiteral("isInline"), value);
            return castState<IsInlineSet>();
        }

        Builder<STATE | StartLineSet>& setStartLine(double value)
        {
            COMPILE_ASSERT(!(STATE & StartLineSet), property_startLine_already_set);
            m_result->setDouble(ASCIILiteral("startLine"), value);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(double value)
        {
            COMPILE_ASSERT(!(STATE & StartColumnSet), property_startColumn_already_set);
            m_result->setDouble(ASCIILiteral("startColumn"), value);
            return castState<StartColumnSet>();
        }

        Ref<CSSStyleSheetHeader> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleSheetHeader) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSStyleSheetHeader>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleSheetHeader> result = CSSStyleSheetHeader::create()
     *     .setStyleSheetId(...)
     *     .setFrameId(...)
     *     .setSourceURL(...)
     *     .setOrigin(...)
     *     .setTitle(...)
     *     .setDisabled(...)
     *     .setIsInline(...)
     *     .setStartLine(...)
     *     .setStartColumn(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS stylesheet contents. */
class CSSStyleSheetBody : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StyleSheetIdSet = 1 << 0,
        RulesSet = 1 << 1,
        AllFieldsSet = (StyleSheetIdSet | RulesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyleSheetBody*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyleSheetBody;
    public:

        Builder<STATE | StyleSheetIdSet>& setStyleSheetId(const Inspector::Protocol::CSS::StyleSheetId& value)
        {
            COMPILE_ASSERT(!(STATE & StyleSheetIdSet), property_styleSheetId_already_set);
            m_result->setString(ASCIILiteral("styleSheetId"), value);
            return castState<StyleSheetIdSet>();
        }

        Builder<STATE | RulesSet>& setRules(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> value)
        {
            COMPILE_ASSERT(!(STATE & RulesSet), property_rules_already_set);
            m_result->setArray(ASCIILiteral("rules"), value);
            return castState<RulesSet>();
        }

        Ref<CSSStyleSheetBody> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyleSheetBody) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSStyleSheetBody>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyleSheetBody> result = CSSStyleSheetBody::create()
     *     .setStyleSheetId(...)
     *     .setRules(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setText(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("text"), value);
    }
};

/* CSS rule representation. */
class CSSRule : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SelectorListSet = 1 << 0,
        SourceLineSet = 1 << 1,
        OriginSet = 1 << 2,
        StyleSet = 1 << 3,
        AllFieldsSet = (SelectorListSet | SourceLineSet | OriginSet | StyleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSRule*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSRule;
    public:

        Builder<STATE | SelectorListSet>& setSelectorList(RefPtr<Inspector::Protocol::CSS::SelectorList> value)
        {
            COMPILE_ASSERT(!(STATE & SelectorListSet), property_selectorList_already_set);
            m_result->setObject(ASCIILiteral("selectorList"), value);
            return castState<SelectorListSet>();
        }

        Builder<STATE | SourceLineSet>& setSourceLine(int value)
        {
            COMPILE_ASSERT(!(STATE & SourceLineSet), property_sourceLine_already_set);
            m_result->setInteger(ASCIILiteral("sourceLine"), value);
            return castState<SourceLineSet>();
        }

        Builder<STATE | OriginSet>& setOrigin(Inspector::Protocol::CSS::StyleSheetOrigin value)
        {
            COMPILE_ASSERT(!(STATE & OriginSet), property_origin_already_set);
            m_result->setString(ASCIILiteral("origin"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<OriginSet>();
        }

        Builder<STATE | StyleSet>& setStyle(RefPtr<Inspector::Protocol::CSS::CSSStyle> value)
        {
            COMPILE_ASSERT(!(STATE & StyleSet), property_style_already_set);
            m_result->setObject(ASCIILiteral("style"), value);
            return castState<StyleSet>();
        }

        Ref<CSSRule> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSRule) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSRule>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSRule> result = CSSRule::create()
     *     .setSelectorList(...)
     *     .setSourceLine(...)
     *     .setOrigin(...)
     *     .setStyle(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRuleId(RefPtr<Inspector::Protocol::CSS::CSSRuleId> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("ruleId"), WTFMove(value));
    }

    void setSourceURL(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("sourceURL"), value);
    }

    void setMedia(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("media"), WTFMove(value));
    }
};

/* Text range within a resource. */
class SourceRange : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartLineSet = 1 << 0,
        StartColumnSet = 1 << 1,
        EndLineSet = 1 << 2,
        EndColumnSet = 1 << 3,
        AllFieldsSet = (StartLineSet | StartColumnSet | EndLineSet | EndColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SourceRange*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SourceRange;
    public:

        Builder<STATE | StartLineSet>& setStartLine(int value)
        {
            COMPILE_ASSERT(!(STATE & StartLineSet), property_startLine_already_set);
            m_result->setInteger(ASCIILiteral("startLine"), value);
            return castState<StartLineSet>();
        }

        Builder<STATE | StartColumnSet>& setStartColumn(int value)
        {
            COMPILE_ASSERT(!(STATE & StartColumnSet), property_startColumn_already_set);
            m_result->setInteger(ASCIILiteral("startColumn"), value);
            return castState<StartColumnSet>();
        }

        Builder<STATE | EndLineSet>& setEndLine(int value)
        {
            COMPILE_ASSERT(!(STATE & EndLineSet), property_endLine_already_set);
            m_result->setInteger(ASCIILiteral("endLine"), value);
            return castState<EndLineSet>();
        }

        Builder<STATE | EndColumnSet>& setEndColumn(int value)
        {
            COMPILE_ASSERT(!(STATE & EndColumnSet), property_endColumn_already_set);
            m_result->setInteger(ASCIILiteral("endColumn"), value);
            return castState<EndColumnSet>();
        }

        Ref<SourceRange> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SourceRange) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<SourceRange>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SourceRange> result = SourceRange::create()
     *     .setStartLine(...)
     *     .setStartColumn(...)
     *     .setEndLine(...)
     *     .setEndColumn(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class ShorthandEntry : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ShorthandEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ShorthandEntry;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Ref<ShorthandEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ShorthandEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ShorthandEntry>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ShorthandEntry> result = ShorthandEntry::create()
     *     .setName(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class CSSPropertyInfo : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSPropertyInfo*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSPropertyInfo;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Ref<CSSPropertyInfo> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSPropertyInfo) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSPropertyInfo>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSPropertyInfo> result = CSSPropertyInfo::create()
     *     .setName(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setLonghands(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("longhands"), WTFMove(value));
    }

    void setValues(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("values"), WTFMove(value));
    }
};

class CSSComputedStyleProperty : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSComputedStyleProperty*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSComputedStyleProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Ref<CSSComputedStyleProperty> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSComputedStyleProperty) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSComputedStyleProperty>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSComputedStyleProperty> result = CSSComputedStyleProperty::create()
     *     .setName(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* CSS style representation. */
class CSSStyle : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CssPropertiesSet = 1 << 0,
        ShorthandEntriesSet = 1 << 1,
        AllFieldsSet = (CssPropertiesSet | ShorthandEntriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSStyle*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSStyle;
    public:

        Builder<STATE | CssPropertiesSet>& setCssProperties(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>> value)
        {
            COMPILE_ASSERT(!(STATE & CssPropertiesSet), property_cssProperties_already_set);
            m_result->setArray(ASCIILiteral("cssProperties"), value);
            return castState<CssPropertiesSet>();
        }

        Builder<STATE | ShorthandEntriesSet>& setShorthandEntries(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>> value)
        {
            COMPILE_ASSERT(!(STATE & ShorthandEntriesSet), property_shorthandEntries_already_set);
            m_result->setArray(ASCIILiteral("shorthandEntries"), value);
            return castState<ShorthandEntriesSet>();
        }

        Ref<CSSStyle> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSStyle) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSStyle>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSStyle> result = CSSStyle::create()
     *     .setCssProperties(...)
     *     .setShorthandEntries(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setStyleId(RefPtr<Inspector::Protocol::CSS::CSSStyleId> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("styleId"), WTFMove(value));
    }

    void setCssText(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("cssText"), value);
    }

    void setRange(RefPtr<Inspector::Protocol::CSS::SourceRange> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("range"), WTFMove(value));
    }

    void setWidth(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("width"), value);
    }

    void setHeight(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("height"), value);
    }
};

/* The property status: "active" if the property is effective in the style, "inactive" if the property is overridden by a same-named property in this style later on, "disabled" if the property is disabled by the user, "style" (implied if absent) if the property is reported by the browser rather than by the CSS source parser. */
enum class CSSPropertyStatus {
    Active = 4,
    Inactive = 5,
    Disabled = 6,
    Style = 7,
}; // enum class CSSPropertyStatus
/* CSS style effective visual dimensions and source offsets. */
class CSSProperty : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        AllFieldsSet = (NameSet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSProperty*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSProperty;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Ref<CSSProperty> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSProperty) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSProperty>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSProperty> result = CSSProperty::create()
     *     .setName(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setPriority(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("priority"), value);
    }

    void setImplicit(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("implicit"), value);
    }

    void setText(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("text"), value);
    }

    void setParsedOk(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("parsedOk"), value);
    }

    void setStatus(Inspector::Protocol::CSS::CSSPropertyStatus value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("status"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setRange(RefPtr<Inspector::Protocol::CSS::SourceRange> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("range"), WTFMove(value));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* Name;
    JS_EXPORT_PRIVATE static const char* Value;
    JS_EXPORT_PRIVATE static const char* Priority;
    JS_EXPORT_PRIVATE static const char* Implicit;
    JS_EXPORT_PRIVATE static const char* Text;
    JS_EXPORT_PRIVATE static const char* ParsedOk;
    JS_EXPORT_PRIVATE static const char* Status;
    JS_EXPORT_PRIVATE static const char* Range;
};

/* CSS media query descriptor. */
class CSSMedia : public JSON::ObjectBase {
public:
    // Named after property name 'source' while generating CSSMedia.
    enum class Source {
        MediaRule = 8,
        ImportRule = 9,
        LinkedSheet = 10,
        InlineSheet = 11,
    }; // enum class Source
    enum {
        NoFieldsSet = 0,
        TextSet = 1 << 0,
        SourceSet = 1 << 1,
        AllFieldsSet = (TextSet | SourceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSSMedia*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSSMedia;
    public:

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        Builder<STATE | SourceSet>& setSource(Source value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString(ASCIILiteral("source"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Ref<CSSMedia> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSSMedia) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSSMedia>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSSMedia> result = CSSMedia::create()
     *     .setText(...)
     *     .setSource(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSourceURL(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("sourceURL"), value);
    }

    void setSourceLine(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("sourceLine"), value);
    }
};

} // CSS

namespace Canvas {
/* The type of rendering context backing the canvas element. */
enum class ContextType {
    Canvas2D = 12,
    WebGL = 13,
    WebGL2 = 14,
    WebGPU = 15,
}; // enum class ContextType
/* Shader type. WebGL supports vertex and fragment shaders. */
enum class ShaderType {
    Fragment = 16,
    Vertex = 17,
}; // enum class ShaderType
/* WebGL drawing surface attributes. */
class ContextAttributes : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AlphaSet = 1 << 0,
        DepthSet = 1 << 1,
        StencilSet = 1 << 2,
        AntialiasSet = 1 << 3,
        PremultipliedAlphaSet = 1 << 4,
        PreserveDrawingBufferSet = 1 << 5,
        FailIfMajorPerformanceCaveatSet = 1 << 6,
        AllFieldsSet = (AlphaSet | DepthSet | StencilSet | AntialiasSet | PremultipliedAlphaSet | PreserveDrawingBufferSet | FailIfMajorPerformanceCaveatSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ContextAttributes*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ContextAttributes;
    public:

        Builder<STATE | AlphaSet>& setAlpha(bool value)
        {
            COMPILE_ASSERT(!(STATE & AlphaSet), property_alpha_already_set);
            m_result->setBoolean(ASCIILiteral("alpha"), value);
            return castState<AlphaSet>();
        }

        Builder<STATE | DepthSet>& setDepth(bool value)
        {
            COMPILE_ASSERT(!(STATE & DepthSet), property_depth_already_set);
            m_result->setBoolean(ASCIILiteral("depth"), value);
            return castState<DepthSet>();
        }

        Builder<STATE | StencilSet>& setStencil(bool value)
        {
            COMPILE_ASSERT(!(STATE & StencilSet), property_stencil_already_set);
            m_result->setBoolean(ASCIILiteral("stencil"), value);
            return castState<StencilSet>();
        }

        Builder<STATE | AntialiasSet>& setAntialias(bool value)
        {
            COMPILE_ASSERT(!(STATE & AntialiasSet), property_antialias_already_set);
            m_result->setBoolean(ASCIILiteral("antialias"), value);
            return castState<AntialiasSet>();
        }

        Builder<STATE | PremultipliedAlphaSet>& setPremultipliedAlpha(bool value)
        {
            COMPILE_ASSERT(!(STATE & PremultipliedAlphaSet), property_premultipliedAlpha_already_set);
            m_result->setBoolean(ASCIILiteral("premultipliedAlpha"), value);
            return castState<PremultipliedAlphaSet>();
        }

        Builder<STATE | PreserveDrawingBufferSet>& setPreserveDrawingBuffer(bool value)
        {
            COMPILE_ASSERT(!(STATE & PreserveDrawingBufferSet), property_preserveDrawingBuffer_already_set);
            m_result->setBoolean(ASCIILiteral("preserveDrawingBuffer"), value);
            return castState<PreserveDrawingBufferSet>();
        }

        Builder<STATE | FailIfMajorPerformanceCaveatSet>& setFailIfMajorPerformanceCaveat(bool value)
        {
            COMPILE_ASSERT(!(STATE & FailIfMajorPerformanceCaveatSet), property_failIfMajorPerformanceCaveat_already_set);
            m_result->setBoolean(ASCIILiteral("failIfMajorPerformanceCaveat"), value);
            return castState<FailIfMajorPerformanceCaveatSet>();
        }

        Ref<ContextAttributes> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ContextAttributes) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ContextAttributes>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ContextAttributes> result = ContextAttributes::create()
     *     .setAlpha(...)
     *     .setDepth(...)
     *     .setStencil(...)
     *     .setAntialias(...)
     *     .setPremultipliedAlpha(...)
     *     .setPreserveDrawingBuffer(...)
     *     .setFailIfMajorPerformanceCaveat(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Information about a canvas for which a rendering context has been created. */
class Canvas : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CanvasIdSet = 1 << 0,
        ContextTypeSet = 1 << 1,
        FrameIdSet = 1 << 2,
        AllFieldsSet = (CanvasIdSet | ContextTypeSet | FrameIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Canvas*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Canvas;
    public:

        Builder<STATE | CanvasIdSet>& setCanvasId(const Inspector::Protocol::Canvas::CanvasId& value)
        {
            COMPILE_ASSERT(!(STATE & CanvasIdSet), property_canvasId_already_set);
            m_result->setString(ASCIILiteral("canvasId"), value);
            return castState<CanvasIdSet>();
        }

        Builder<STATE | ContextTypeSet>& setContextType(Inspector::Protocol::Canvas::ContextType value)
        {
            COMPILE_ASSERT(!(STATE & ContextTypeSet), property_contextType_already_set);
            m_result->setString(ASCIILiteral("contextType"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<ContextTypeSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::Protocol::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Ref<Canvas> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Canvas) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Canvas>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Canvas> result = Canvas::create()
     *     .setCanvasId(...)
     *     .setContextType(...)
     *     .setFrameId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setNodeId(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("nodeId"), value);
    }

    void setCssCanvasName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("cssCanvasName"), value);
    }

    void setContextAttributes(RefPtr<Inspector::Protocol::Canvas::ContextAttributes> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("contextAttributes"), WTFMove(value));
    }

    void setMemoryCost(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("memoryCost"), value);
    }

    void setBacktrace(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Console::CallFrame>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("backtrace"), WTFMove(value));
    }
};

} // Canvas

namespace Console {
/* Channels for different types of log messages. */
enum class ChannelSource {
    XML = 18,
    Javascript = 19,
    Network = 20,
    ConsoleAPI = 21,
    Storage = 22,
    Appcache = 23,
    Rendering = 24,
    CSS = 25,
    Security = 26,
    ContentBlocker = 27,
    Media = 28,
    WebRTC = 29,
    Other = 30,
}; // enum class ChannelSource
/* Level of logging. */
enum class ChannelLevel {
    Off = 31,
    Log = 32,
    Error = 33,
    Warning = 34,
    Info = 35,
    Debug = 36,
}; // enum class ChannelLevel
/* Logging channel. */
class Channel : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        AllFieldsSet = (SourceSet | LevelSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Channel*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Channel;
    public:

        Builder<STATE | SourceSet>& setSource(Inspector::Protocol::Console::ChannelSource value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString(ASCIILiteral("source"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Inspector::Protocol::Console::ChannelLevel value)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString(ASCIILiteral("level"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<LevelSet>();
        }

        Ref<Channel> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Channel) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Channel>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Channel> result = Channel::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Console message. */
class ConsoleMessage : public JSON::ObjectBase {
public:
    // Named after property name 'level' while generating ConsoleMessage.
    enum class Level {
        Log = 32,
        Info = 35,
        Warning = 34,
        Error = 33,
        Debug = 36,
    }; // enum class Level
    // Named after property name 'type' while generating ConsoleMessage.
    enum class Type {
        Log = 32,
        Dir = 37,
        DirXML = 38,
        Table = 39,
        Trace = 40,
        Clear = 41,
        StartGroup = 42,
        StartGroupCollapsed = 43,
        EndGroup = 44,
        Assert = 45,
        Timing = 46,
        Profile = 47,
        ProfileEnd = 48,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        SourceSet = 1 << 0,
        LevelSet = 1 << 1,
        TextSet = 1 << 2,
        AllFieldsSet = (SourceSet | LevelSet | TextSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ConsoleMessage*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ConsoleMessage;
    public:

        Builder<STATE | SourceSet>& setSource(Inspector::Protocol::Console::ChannelSource value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString(ASCIILiteral("source"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Builder<STATE | LevelSet>& setLevel(Level value)
        {
            COMPILE_ASSERT(!(STATE & LevelSet), property_level_already_set);
            m_result->setString(ASCIILiteral("level"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<LevelSet>();
        }

        Builder<STATE | TextSet>& setText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TextSet), property_text_already_set);
            m_result->setString(ASCIILiteral("text"), value);
            return castState<TextSet>();
        }

        Ref<ConsoleMessage> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ConsoleMessage) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ConsoleMessage>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ConsoleMessage> result = ConsoleMessage::create()
     *     .setSource(...)
     *     .setLevel(...)
     *     .setText(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setType(Type value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setUrl(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("url"), value);
    }

    void setLine(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("line"), value);
    }

    void setColumn(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("column"), value);
    }

    void setRepeatCount(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("repeatCount"), value);
    }

    void setParameters(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::RemoteObject>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("parameters"), WTFMove(value));
    }

    void setStackTrace(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Console::CallFrame>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("stackTrace"), WTFMove(value));
    }

    void setNetworkRequestId(const Inspector::Protocol::Network::RequestId& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("networkRequestId"), value);
    }
};

/* Stack entry for console errors and assertions. */
class CallFrame : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FunctionNameSet = 1 << 0,
        UrlSet = 1 << 1,
        ScriptIdSet = 1 << 2,
        LineNumberSet = 1 << 3,
        ColumnNumberSet = 1 << 4,
        AllFieldsSet = (FunctionNameSet | UrlSet | ScriptIdSet | LineNumberSet | ColumnNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CallFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CallFrame;
    public:

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString(ASCIILiteral("functionName"), value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | ScriptIdSet>& setScriptId(const Inspector::Protocol::Debugger::ScriptId& value)
        {
            COMPILE_ASSERT(!(STATE & ScriptIdSet), property_scriptId_already_set);
            m_result->setString(ASCIILiteral("scriptId"), value);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setInteger(ASCIILiteral("lineNumber"), value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & ColumnNumberSet), property_columnNumber_already_set);
            m_result->setInteger(ASCIILiteral("columnNumber"), value);
            return castState<ColumnNumberSet>();
        }

        Ref<CallFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CallFrame>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CallFrame> result = CallFrame::create()
     *     .setFunctionName(...)
     *     .setUrl(...)
     *     .setScriptId(...)
     *     .setLineNumber(...)
     *     .setColumnNumber(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Call frames for async function calls, console assertions, and error messages. */
class StackTrace : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFramesSet = 1 << 0,
        AllFieldsSet = (CallFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackTrace*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StackTrace;
    public:

        Builder<STATE | CallFramesSet>& setCallFrames(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Console::CallFrame>> value)
        {
            COMPILE_ASSERT(!(STATE & CallFramesSet), property_callFrames_already_set);
            m_result->setArray(ASCIILiteral("callFrames"), value);
            return castState<CallFramesSet>();
        }

        Ref<StackTrace> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StackTrace) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<StackTrace>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackTrace> result = StackTrace::create()
     *     .setCallFrames(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setTopCallFrameIsBoundary(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("topCallFrameIsBoundary"), value);
    }

    void setTruncated(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("truncated"), value);
    }

    void setParentStackTrace(RefPtr<Inspector::Protocol::Console::StackTrace> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("parentStackTrace"), WTFMove(value));
    }
};

} // Console

namespace DOM {
/* Pseudo element type. */
enum class PseudoType {
    Before = 49,
    After = 50,
}; // enum class PseudoType
/* Shadow root type. */
enum class ShadowRootType {
    UserAgent = 1,
    Open = 51,
    Closed = 52,
}; // enum class ShadowRootType
/* Custom element state. */
enum class CustomElementState {
    Builtin = 53,
    Custom = 54,
    Waiting = 55,
    Failed = 56,
}; // enum class CustomElementState
/* Token values of @aria-relevant attribute. */
enum class LiveRegionRelevant {
    Additions = 57,
    Removals = 58,
    Text = 59,
}; // enum class LiveRegionRelevant
/* DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type. */
class Node : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NodeIdSet = 1 << 0,
        NodeTypeSet = 1 << 1,
        NodeNameSet = 1 << 2,
        LocalNameSet = 1 << 3,
        NodeValueSet = 1 << 4,
        AllFieldsSet = (NodeIdSet | NodeTypeSet | NodeNameSet | LocalNameSet | NodeValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Node*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Node;
    public:

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeTypeSet), property_nodeType_already_set);
            m_result->setInteger(ASCIILiteral("nodeType"), value);
            return castState<NodeTypeSet>();
        }

        Builder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeNameSet), property_nodeName_already_set);
            m_result->setString(ASCIILiteral("nodeName"), value);
            return castState<NodeNameSet>();
        }

        Builder<STATE | LocalNameSet>& setLocalName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LocalNameSet), property_localName_already_set);
            m_result->setString(ASCIILiteral("localName"), value);
            return castState<LocalNameSet>();
        }

        Builder<STATE | NodeValueSet>& setNodeValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NodeValueSet), property_nodeValue_already_set);
            m_result->setString(ASCIILiteral("nodeValue"), value);
            return castState<NodeValueSet>();
        }

        Ref<Node> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Node) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Node>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Node> result = Node::create()
     *     .setNodeId(...)
     *     .setNodeType(...)
     *     .setNodeName(...)
     *     .setLocalName(...)
     *     .setNodeValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setChildNodeCount(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("childNodeCount"), value);
    }

    void setChildren(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::Node>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("children"), WTFMove(value));
    }

    void setAttributes(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("attributes"), WTFMove(value));
    }

    void setDocumentURL(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("documentURL"), value);
    }

    void setBaseURL(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("baseURL"), value);
    }

    void setPublicId(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("publicId"), value);
    }

    void setSystemId(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("systemId"), value);
    }

    void setXmlVersion(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("xmlVersion"), value);
    }

    void setName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("name"), value);
    }

    void setValue(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("value"), value);
    }

    void setPseudoType(Inspector::Protocol::DOM::PseudoType value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("pseudoType"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setShadowRootType(Inspector::Protocol::DOM::ShadowRootType value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("shadowRootType"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setCustomElementState(Inspector::Protocol::DOM::CustomElementState value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("customElementState"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setFrameId(const Inspector::Protocol::Network::FrameId& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("frameId"), value);
    }

    void setContentDocument(RefPtr<Inspector::Protocol::DOM::Node> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("contentDocument"), WTFMove(value));
    }

    void setShadowRoots(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::Node>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("shadowRoots"), WTFMove(value));
    }

    void setTemplateContent(RefPtr<Inspector::Protocol::DOM::Node> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("templateContent"), WTFMove(value));
    }

    void setPseudoElements(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::Node>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("pseudoElements"), WTFMove(value));
    }

    void setRole(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("role"), value);
    }

    void setContentSecurityPolicyHash(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("contentSecurityPolicyHash"), value);
    }
};

/* A structure holding event listener properties. */
class EventListener : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        EventListenerIdSet = 1 << 0,
        TypeSet = 1 << 1,
        UseCaptureSet = 1 << 2,
        IsAttributeSet = 1 << 3,
        NodeIdSet = 1 << 4,
        HandlerBodySet = 1 << 5,
        AllFieldsSet = (EventListenerIdSet | TypeSet | UseCaptureSet | IsAttributeSet | NodeIdSet | HandlerBodySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*EventListener*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class EventListener;
    public:

        Builder<STATE | EventListenerIdSet>& setEventListenerId(int value)
        {
            COMPILE_ASSERT(!(STATE & EventListenerIdSet), property_eventListenerId_already_set);
            m_result->setInteger(ASCIILiteral("eventListenerId"), value);
            return castState<EventListenerIdSet>();
        }

        Builder<STATE | TypeSet>& setType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), value);
            return castState<TypeSet>();
        }

        Builder<STATE | UseCaptureSet>& setUseCapture(bool value)
        {
            COMPILE_ASSERT(!(STATE & UseCaptureSet), property_useCapture_already_set);
            m_result->setBoolean(ASCIILiteral("useCapture"), value);
            return castState<UseCaptureSet>();
        }

        Builder<STATE | IsAttributeSet>& setIsAttribute(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsAttributeSet), property_isAttribute_already_set);
            m_result->setBoolean(ASCIILiteral("isAttribute"), value);
            return castState<IsAttributeSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | HandlerBodySet>& setHandlerBody(const String& value)
        {
            COMPILE_ASSERT(!(STATE & HandlerBodySet), property_handlerBody_already_set);
            m_result->setString(ASCIILiteral("handlerBody"), value);
            return castState<HandlerBodySet>();
        }

        Ref<EventListener> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(EventListener) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<EventListener>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<EventListener> result = EventListener::create()
     *     .setEventListenerId(...)
     *     .setType(...)
     *     .setUseCapture(...)
     *     .setIsAttribute(...)
     *     .setNodeId(...)
     *     .setHandlerBody(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setLocation(RefPtr<Inspector::Protocol::Debugger::Location> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("location"), WTFMove(value));
    }

    void setSourceName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("sourceName"), value);
    }

    void setHandler(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("handler"), WTFMove(value));
    }

    void setPassive(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("passive"), value);
    }

    void setOnce(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("once"), value);
    }

    void setDisabled(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("disabled"), value);
    }
};

/* A structure holding accessibility properties. */
class AccessibilityProperties : public JSON::ObjectBase {
public:
    // Named after property name 'checked' while generating AccessibilityProperties.
    enum class Checked {
        True = 60,
        False = 61,
        Mixed = 62,
    }; // enum class Checked
    // Named after property name 'current' while generating AccessibilityProperties.
    enum class Current {
        True = 60,
        False = 61,
        Page = 63,
        Step = 64,
        Location = 65,
        Date = 66,
        Time = 67,
    }; // enum class Current
    // Named after property name 'invalid' while generating AccessibilityProperties.
    enum class Invalid {
        True = 60,
        False = 61,
        Grammar = 68,
        Spelling = 69,
    }; // enum class Invalid
    // Named after property name 'liveRegionStatus' while generating AccessibilityProperties.
    enum class LiveRegionStatus {
        Assertive = 70,
        Polite = 71,
        Off = 31,
    }; // enum class LiveRegionStatus
    enum {
        NoFieldsSet = 0,
        ExistsSet = 1 << 0,
        LabelSet = 1 << 1,
        NodeIdSet = 1 << 2,
        RoleSet = 1 << 3,
        AllFieldsSet = (ExistsSet | LabelSet | NodeIdSet | RoleSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*AccessibilityProperties*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class AccessibilityProperties;
    public:

        Builder<STATE | ExistsSet>& setExists(bool value)
        {
            COMPILE_ASSERT(!(STATE & ExistsSet), property_exists_already_set);
            m_result->setBoolean(ASCIILiteral("exists"), value);
            return castState<ExistsSet>();
        }

        Builder<STATE | LabelSet>& setLabel(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LabelSet), property_label_already_set);
            m_result->setString(ASCIILiteral("label"), value);
            return castState<LabelSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | RoleSet>& setRole(const String& value)
        {
            COMPILE_ASSERT(!(STATE & RoleSet), property_role_already_set);
            m_result->setString(ASCIILiteral("role"), value);
            return castState<RoleSet>();
        }

        Ref<AccessibilityProperties> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(AccessibilityProperties) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<AccessibilityProperties>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<AccessibilityProperties> result = AccessibilityProperties::create()
     *     .setExists(...)
     *     .setLabel(...)
     *     .setNodeId(...)
     *     .setRole(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setActiveDescendantNodeId(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("activeDescendantNodeId"), value);
    }

    void setBusy(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("busy"), value);
    }

    void setChecked(Checked value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("checked"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setChildNodeIds(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("childNodeIds"), WTFMove(value));
    }

    void setControlledNodeIds(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("controlledNodeIds"), WTFMove(value));
    }

    void setCurrent(Current value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("current"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setDisabled(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("disabled"), value);
    }

    void setHeadingLevel(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("headingLevel"), value);
    }

    void setHierarchyLevel(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("hierarchyLevel"), value);
    }

    void setIsPopUpButton(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isPopUpButton"), value);
    }

    void setExpanded(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("expanded"), value);
    }

    void setFlowedNodeIds(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("flowedNodeIds"), WTFMove(value));
    }

    void setFocused(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("focused"), value);
    }

    void setIgnored(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("ignored"), value);
    }

    void setIgnoredByDefault(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("ignoredByDefault"), value);
    }

    void setInvalid(Invalid value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("invalid"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setHidden(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("hidden"), value);
    }

    void setLiveRegionAtomic(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("liveRegionAtomic"), value);
    }

    void setLiveRegionRelevant(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("liveRegionRelevant"), WTFMove(value));
    }

    void setLiveRegionStatus(LiveRegionStatus value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("liveRegionStatus"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setMouseEventNodeId(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("mouseEventNodeId"), value);
    }

    void setOwnedNodeIds(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("ownedNodeIds"), WTFMove(value));
    }

    void setParentNodeId(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("parentNodeId"), value);
    }

    void setPressed(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("pressed"), value);
    }

    void setReadonly(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("readonly"), value);
    }

    void setRequired(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("required"), value);
    }

    void setSelected(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("selected"), value);
    }

    void setSelectedChildNodeIds(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::DOM::NodeId>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("selectedChildNodeIds"), WTFMove(value));
    }
};

/* A structure holding an RGBA color. */
class RGBAColor : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        RSet = 1 << 0,
        GSet = 1 << 1,
        BSet = 1 << 2,
        AllFieldsSet = (RSet | GSet | BSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RGBAColor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class RGBAColor;
    public:

        Builder<STATE | RSet>& setR(int value)
        {
            COMPILE_ASSERT(!(STATE & RSet), property_r_already_set);
            m_result->setInteger(ASCIILiteral("r"), value);
            return castState<RSet>();
        }

        Builder<STATE | GSet>& setG(int value)
        {
            COMPILE_ASSERT(!(STATE & GSet), property_g_already_set);
            m_result->setInteger(ASCIILiteral("g"), value);
            return castState<GSet>();
        }

        Builder<STATE | BSet>& setB(int value)
        {
            COMPILE_ASSERT(!(STATE & BSet), property_b_already_set);
            m_result->setInteger(ASCIILiteral("b"), value);
            return castState<BSet>();
        }

        Ref<RGBAColor> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RGBAColor) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<RGBAColor>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RGBAColor> result = RGBAColor::create()
     *     .setR(...)
     *     .setG(...)
     *     .setB(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setA(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("a"), value);
    }
};

/* Configuration data for the highlighting of page elements. */
class HighlightConfig : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*HighlightConfig*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class HighlightConfig;
    public:

        Ref<HighlightConfig> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(HighlightConfig) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<HighlightConfig>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<HighlightConfig> result = HighlightConfig::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setShowInfo(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("showInfo"), value);
    }

    void setContentColor(RefPtr<Inspector::Protocol::DOM::RGBAColor> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("contentColor"), WTFMove(value));
    }

    void setPaddingColor(RefPtr<Inspector::Protocol::DOM::RGBAColor> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("paddingColor"), WTFMove(value));
    }

    void setBorderColor(RefPtr<Inspector::Protocol::DOM::RGBAColor> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("borderColor"), WTFMove(value));
    }

    void setMarginColor(RefPtr<Inspector::Protocol::DOM::RGBAColor> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("marginColor"), WTFMove(value));
    }
};

} // DOM

namespace DOMDebugger {
/* DOM breakpoint type. */
enum class DOMBreakpointType {
    SubtreeModified = 72,
    AttributeModified = 73,
    NodeRemoved = 74,
}; // enum class DOMBreakpointType
} // DOMDebugger

namespace DOMStorage {
/* DOM Storage identifier. */
class StorageId : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SecurityOriginSet = 1 << 0,
        IsLocalStorageSet = 1 << 1,
        AllFieldsSet = (SecurityOriginSet | IsLocalStorageSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StorageId*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StorageId;
    public:

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString(ASCIILiteral("securityOrigin"), value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | IsLocalStorageSet>& setIsLocalStorage(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsLocalStorageSet), property_isLocalStorage_already_set);
            m_result->setBoolean(ASCIILiteral("isLocalStorage"), value);
            return castState<IsLocalStorageSet>();
        }

        Ref<StorageId> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StorageId) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<StorageId>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StorageId> result = StorageId::create()
     *     .setSecurityOrigin(...)
     *     .setIsLocalStorage(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // DOMStorage

namespace Database {
/* Database object. */
class Database : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        DomainSet = 1 << 1,
        NameSet = 1 << 2,
        VersionSet = 1 << 3,
        AllFieldsSet = (IdSet | DomainSet | NameSet | VersionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Database*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Database;
    public:

        Builder<STATE | IdSet>& setId(const Inspector::Protocol::Database::DatabaseId& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString(ASCIILiteral("domain"), value);
            return castState<DomainSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(const String& value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setString(ASCIILiteral("version"), value);
            return castState<VersionSet>();
        }

        Ref<Database> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Database) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Database>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Database> result = Database::create()
     *     .setId(...)
     *     .setDomain(...)
     *     .setName(...)
     *     .setVersion(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Database error. */
class Error : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Error*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString(ASCIILiteral("message"), value);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int value)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setInteger(ASCIILiteral("code"), value);
            return castState<CodeSet>();
        }

        Ref<Error> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Error>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Database

namespace Debugger {
/* Location in the source code. */
class Location : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ScriptIdSet = 1 << 0,
        LineNumberSet = 1 << 1,
        AllFieldsSet = (ScriptIdSet | LineNumberSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Location*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Location;
    public:

        Builder<STATE | ScriptIdSet>& setScriptId(const Inspector::Protocol::Debugger::ScriptId& value)
        {
            COMPILE_ASSERT(!(STATE & ScriptIdSet), property_scriptId_already_set);
            m_result->setString(ASCIILiteral("scriptId"), value);
            return castState<ScriptIdSet>();
        }

        Builder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setInteger(ASCIILiteral("lineNumber"), value);
            return castState<LineNumberSet>();
        }

        Ref<Location> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Location) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Location>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Location> result = Location::create()
     *     .setScriptId(...)
     *     .setLineNumber(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setColumnNumber(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("columnNumber"), value);
    }
};

/* Action to perform when a breakpoint is triggered. */
class BreakpointAction : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating BreakpointAction.
    enum class Type {
        Log = 32,
        Evaluate = 75,
        Sound = 76,
        Probe = 77,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BreakpointAction*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BreakpointAction;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<BreakpointAction> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BreakpointAction) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<BreakpointAction>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BreakpointAction> result = BreakpointAction::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setData(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("data"), value);
    }

    void setId(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("id"), value);
    }
};

/* Extra options that modify breakpoint behavior. */
class BreakpointOptions : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BreakpointOptions*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BreakpointOptions;
    public:

        Ref<BreakpointOptions> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BreakpointOptions) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<BreakpointOptions>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BreakpointOptions> result = BreakpointOptions::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setCondition(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("condition"), value);
    }

    void setActions(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Debugger::BreakpointAction>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("actions"), WTFMove(value));
    }

    void setAutoContinue(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("autoContinue"), value);
    }

    void setIgnoreCount(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("ignoreCount"), value);
    }
};

/* Information about the function. */
class FunctionDetails : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LocationSet = 1 << 0,
        AllFieldsSet = (LocationSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FunctionDetails*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FunctionDetails;
    public:

        Builder<STATE | LocationSet>& setLocation(RefPtr<Inspector::Protocol::Debugger::Location> value)
        {
            COMPILE_ASSERT(!(STATE & LocationSet), property_location_already_set);
            m_result->setObject(ASCIILiteral("location"), value);
            return castState<LocationSet>();
        }

        Ref<FunctionDetails> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FunctionDetails) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<FunctionDetails>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FunctionDetails> result = FunctionDetails::create()
     *     .setLocation(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("name"), value);
    }

    void setDisplayName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("displayName"), value);
    }

    void setScopeChain(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Debugger::Scope>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("scopeChain"), WTFMove(value));
    }
};

/* JavaScript call frame. Array of call frames form the call stack. */
class CallFrame : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        CallFrameIdSet = 1 << 0,
        FunctionNameSet = 1 << 1,
        LocationSet = 1 << 2,
        ScopeChainSet = 1 << 3,
        ThisSet = 1 << 4,
        IsTailDeletedSet = 1 << 5,
        AllFieldsSet = (CallFrameIdSet | FunctionNameSet | LocationSet | ScopeChainSet | ThisSet | IsTailDeletedSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CallFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CallFrame;
    public:

        Builder<STATE | CallFrameIdSet>& setCallFrameId(const Inspector::Protocol::Debugger::CallFrameId& value)
        {
            COMPILE_ASSERT(!(STATE & CallFrameIdSet), property_callFrameId_already_set);
            m_result->setString(ASCIILiteral("callFrameId"), value);
            return castState<CallFrameIdSet>();
        }

        Builder<STATE | FunctionNameSet>& setFunctionName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & FunctionNameSet), property_functionName_already_set);
            m_result->setString(ASCIILiteral("functionName"), value);
            return castState<FunctionNameSet>();
        }

        Builder<STATE | LocationSet>& setLocation(RefPtr<Inspector::Protocol::Debugger::Location> value)
        {
            COMPILE_ASSERT(!(STATE & LocationSet), property_location_already_set);
            m_result->setObject(ASCIILiteral("location"), value);
            return castState<LocationSet>();
        }

        Builder<STATE | ScopeChainSet>& setScopeChain(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Debugger::Scope>> value)
        {
            COMPILE_ASSERT(!(STATE & ScopeChainSet), property_scopeChain_already_set);
            m_result->setArray(ASCIILiteral("scopeChain"), value);
            return castState<ScopeChainSet>();
        }

        Builder<STATE | ThisSet>& setThis(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & ThisSet), property_this_already_set);
            m_result->setObject(ASCIILiteral("this"), value);
            return castState<ThisSet>();
        }

        Builder<STATE | IsTailDeletedSet>& setIsTailDeleted(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsTailDeletedSet), property_isTailDeleted_already_set);
            m_result->setBoolean(ASCIILiteral("isTailDeleted"), value);
            return castState<IsTailDeletedSet>();
        }

        Ref<CallFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CallFrame>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CallFrame> result = CallFrame::create()
     *     .setCallFrameId(...)
     *     .setFunctionName(...)
     *     .setLocation(...)
     *     .setScopeChain(...)
     *     .setThis(...)
     *     .setIsTailDeleted(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Scope description. */
class Scope : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating Scope.
    enum class Type {
        Global = 78,
        With = 79,
        Closure = 80,
        Catch = 81,
        FunctionName = 82,
        GlobalLexicalEnvironment = 83,
        NestedLexical = 84,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        ObjectSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (ObjectSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Scope*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Scope;
    public:

        Builder<STATE | ObjectSet>& setObject(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & ObjectSet), property_object_already_set);
            m_result->setObject(ASCIILiteral("object"), value);
            return castState<ObjectSet>();
        }

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<Scope> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Scope) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Scope>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Scope> result = Scope::create()
     *     .setObject(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("name"), value);
    }

    void setLocation(RefPtr<Inspector::Protocol::Debugger::Location> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("location"), WTFMove(value));
    }

    void setEmpty(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("empty"), value);
    }
};

/* A sample collected by evaluating a probe breakpoint action. */
class ProbeSample : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ProbeIdSet = 1 << 0,
        SampleIdSet = 1 << 1,
        BatchIdSet = 1 << 2,
        TimestampSet = 1 << 3,
        PayloadSet = 1 << 4,
        AllFieldsSet = (ProbeIdSet | SampleIdSet | BatchIdSet | TimestampSet | PayloadSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ProbeSample*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ProbeSample;
    public:

        Builder<STATE | ProbeIdSet>& setProbeId(int value)
        {
            COMPILE_ASSERT(!(STATE & ProbeIdSet), property_probeId_already_set);
            m_result->setInteger(ASCIILiteral("probeId"), value);
            return castState<ProbeIdSet>();
        }

        Builder<STATE | SampleIdSet>& setSampleId(int value)
        {
            COMPILE_ASSERT(!(STATE & SampleIdSet), property_sampleId_already_set);
            m_result->setInteger(ASCIILiteral("sampleId"), value);
            return castState<SampleIdSet>();
        }

        Builder<STATE | BatchIdSet>& setBatchId(int value)
        {
            COMPILE_ASSERT(!(STATE & BatchIdSet), property_batchId_already_set);
            m_result->setInteger(ASCIILiteral("batchId"), value);
            return castState<BatchIdSet>();
        }

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble(ASCIILiteral("timestamp"), value);
            return castState<TimestampSet>();
        }

        Builder<STATE | PayloadSet>& setPayload(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & PayloadSet), property_payload_already_set);
            m_result->setObject(ASCIILiteral("payload"), value);
            return castState<PayloadSet>();
        }

        Ref<ProbeSample> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ProbeSample) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ProbeSample>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ProbeSample> result = ProbeSample::create()
     *     .setProbeId(...)
     *     .setSampleId(...)
     *     .setBatchId(...)
     *     .setTimestamp(...)
     *     .setPayload(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* The pause reason auxiliary data when paused because of an assertion. */
class AssertPauseReason : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*AssertPauseReason*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class AssertPauseReason;
    public:

        Ref<AssertPauseReason> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(AssertPauseReason) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<AssertPauseReason>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<AssertPauseReason> result = AssertPauseReason::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setMessage(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("message"), value);
    }
};

/* The pause reason auxiliary data when paused because of hitting a breakpoint. */
class BreakpointPauseReason : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        BreakpointIdSet = 1 << 0,
        AllFieldsSet = (BreakpointIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BreakpointPauseReason*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BreakpointPauseReason;
    public:

        Builder<STATE | BreakpointIdSet>& setBreakpointId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & BreakpointIdSet), property_breakpointId_already_set);
            m_result->setString(ASCIILiteral("breakpointId"), value);
            return castState<BreakpointIdSet>();
        }

        Ref<BreakpointPauseReason> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BreakpointPauseReason) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<BreakpointPauseReason>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BreakpointPauseReason> result = BreakpointPauseReason::create()
     *     .setBreakpointId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* The pause reason auxiliary data when paused because of a Content Security Policy directive. */
class CSPViolationPauseReason : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DirectiveSet = 1 << 0,
        AllFieldsSet = (DirectiveSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CSPViolationPauseReason*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CSPViolationPauseReason;
    public:

        Builder<STATE | DirectiveSet>& setDirective(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DirectiveSet), property_directive_already_set);
            m_result->setString(ASCIILiteral("directive"), value);
            return castState<DirectiveSet>();
        }

        Ref<CSPViolationPauseReason> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CSPViolationPauseReason) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CSPViolationPauseReason>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CSPViolationPauseReason> result = CSPViolationPauseReason::create()
     *     .setDirective(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Debugger

namespace GenericTypes {
/* Search match in a resource. */
class SearchMatch : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineNumberSet = 1 << 0,
        LineContentSet = 1 << 1,
        AllFieldsSet = (LineNumberSet | LineContentSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SearchMatch*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SearchMatch;
    public:

        Builder<STATE | LineNumberSet>& setLineNumber(double value)
        {
            COMPILE_ASSERT(!(STATE & LineNumberSet), property_lineNumber_already_set);
            m_result->setDouble(ASCIILiteral("lineNumber"), value);
            return castState<LineNumberSet>();
        }

        Builder<STATE | LineContentSet>& setLineContent(const String& value)
        {
            COMPILE_ASSERT(!(STATE & LineContentSet), property_lineContent_already_set);
            m_result->setString(ASCIILiteral("lineContent"), value);
            return castState<LineContentSet>();
        }

        Ref<SearchMatch> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SearchMatch) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<SearchMatch>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SearchMatch> result = SearchMatch::create()
     *     .setLineNumber(...)
     *     .setLineContent(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // GenericTypes

namespace Heap {
/* Information about a garbage collection. */
class GarbageCollection : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating GarbageCollection.
    enum class Type {
        Full = 85,
        Partial = 86,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        StartTimeSet = 1 << 1,
        EndTimeSet = 1 << 2,
        AllFieldsSet = (TypeSet | StartTimeSet | EndTimeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*GarbageCollection*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class GarbageCollection;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | StartTimeSet>& setStartTime(double value)
        {
            COMPILE_ASSERT(!(STATE & StartTimeSet), property_startTime_already_set);
            m_result->setDouble(ASCIILiteral("startTime"), value);
            return castState<StartTimeSet>();
        }

        Builder<STATE | EndTimeSet>& setEndTime(double value)
        {
            COMPILE_ASSERT(!(STATE & EndTimeSet), property_endTime_already_set);
            m_result->setDouble(ASCIILiteral("endTime"), value);
            return castState<EndTimeSet>();
        }

        Ref<GarbageCollection> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(GarbageCollection) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<GarbageCollection>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<GarbageCollection> result = GarbageCollection::create()
     *     .setType(...)
     *     .setStartTime(...)
     *     .setEndTime(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Heap

#if ENABLE(INDEXED_DATABASE)
namespace IndexedDB {
/* Database with an array of object stores. */
class DatabaseWithObjectStores : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        VersionSet = 1 << 1,
        ObjectStoresSet = 1 << 2,
        AllFieldsSet = (NameSet | VersionSet | ObjectStoresSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*DatabaseWithObjectStores*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class DatabaseWithObjectStores;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | VersionSet>& setVersion(double value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setDouble(ASCIILiteral("version"), value);
            return castState<VersionSet>();
        }

        Builder<STATE | ObjectStoresSet>& setObjectStores(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::IndexedDB::ObjectStore>> value)
        {
            COMPILE_ASSERT(!(STATE & ObjectStoresSet), property_objectStores_already_set);
            m_result->setArray(ASCIILiteral("objectStores"), value);
            return castState<ObjectStoresSet>();
        }

        Ref<DatabaseWithObjectStores> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DatabaseWithObjectStores) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<DatabaseWithObjectStores>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<DatabaseWithObjectStores> result = DatabaseWithObjectStores::create()
     *     .setName(...)
     *     .setVersion(...)
     *     .setObjectStores(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Object store. */
class ObjectStore : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        AutoIncrementSet = 1 << 2,
        IndexesSet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | AutoIncrementSet | IndexesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ObjectStore*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ObjectStore;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(RefPtr<Inspector::Protocol::IndexedDB::KeyPath> value)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setObject(ASCIILiteral("keyPath"), value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | AutoIncrementSet>& setAutoIncrement(bool value)
        {
            COMPILE_ASSERT(!(STATE & AutoIncrementSet), property_autoIncrement_already_set);
            m_result->setBoolean(ASCIILiteral("autoIncrement"), value);
            return castState<AutoIncrementSet>();
        }

        Builder<STATE | IndexesSet>& setIndexes(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::IndexedDB::ObjectStoreIndex>> value)
        {
            COMPILE_ASSERT(!(STATE & IndexesSet), property_indexes_already_set);
            m_result->setArray(ASCIILiteral("indexes"), value);
            return castState<IndexesSet>();
        }

        Ref<ObjectStore> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectStore) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ObjectStore>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ObjectStore> result = ObjectStore::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setAutoIncrement(...)
     *     .setIndexes(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Object store index. */
class ObjectStoreIndex : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        KeyPathSet = 1 << 1,
        UniqueSet = 1 << 2,
        MultiEntrySet = 1 << 3,
        AllFieldsSet = (NameSet | KeyPathSet | UniqueSet | MultiEntrySet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ObjectStoreIndex*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ObjectStoreIndex;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | KeyPathSet>& setKeyPath(RefPtr<Inspector::Protocol::IndexedDB::KeyPath> value)
        {
            COMPILE_ASSERT(!(STATE & KeyPathSet), property_keyPath_already_set);
            m_result->setObject(ASCIILiteral("keyPath"), value);
            return castState<KeyPathSet>();
        }

        Builder<STATE | UniqueSet>& setUnique(bool value)
        {
            COMPILE_ASSERT(!(STATE & UniqueSet), property_unique_already_set);
            m_result->setBoolean(ASCIILiteral("unique"), value);
            return castState<UniqueSet>();
        }

        Builder<STATE | MultiEntrySet>& setMultiEntry(bool value)
        {
            COMPILE_ASSERT(!(STATE & MultiEntrySet), property_multiEntry_already_set);
            m_result->setBoolean(ASCIILiteral("multiEntry"), value);
            return castState<MultiEntrySet>();
        }

        Ref<ObjectStoreIndex> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectStoreIndex) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ObjectStoreIndex>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ObjectStoreIndex> result = ObjectStoreIndex::create()
     *     .setName(...)
     *     .setKeyPath(...)
     *     .setUnique(...)
     *     .setMultiEntry(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Key. */
class Key : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating Key.
    enum class Type {
        Number = 87,
        String = 88,
        Date = 66,
        Array = 89,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Key*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Key;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<Key> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Key) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Key>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Key> result = Key::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setNumber(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("number"), value);
    }

    void setString(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("string"), value);
    }

    void setDate(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("date"), value);
    }

    void setArray(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::IndexedDB::Key>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("array"), WTFMove(value));
    }
};

/* Key range. */
class KeyRange : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LowerOpenSet = 1 << 0,
        UpperOpenSet = 1 << 1,
        AllFieldsSet = (LowerOpenSet | UpperOpenSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*KeyRange*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class KeyRange;
    public:

        Builder<STATE | LowerOpenSet>& setLowerOpen(bool value)
        {
            COMPILE_ASSERT(!(STATE & LowerOpenSet), property_lowerOpen_already_set);
            m_result->setBoolean(ASCIILiteral("lowerOpen"), value);
            return castState<LowerOpenSet>();
        }

        Builder<STATE | UpperOpenSet>& setUpperOpen(bool value)
        {
            COMPILE_ASSERT(!(STATE & UpperOpenSet), property_upperOpen_already_set);
            m_result->setBoolean(ASCIILiteral("upperOpen"), value);
            return castState<UpperOpenSet>();
        }

        Ref<KeyRange> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyRange) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<KeyRange>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<KeyRange> result = KeyRange::create()
     *     .setLowerOpen(...)
     *     .setUpperOpen(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setLower(RefPtr<Inspector::Protocol::IndexedDB::Key> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("lower"), WTFMove(value));
    }

    void setUpper(RefPtr<Inspector::Protocol::IndexedDB::Key> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("upper"), WTFMove(value));
    }
};

/* Data entry. */
class DataEntry : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        KeySet = 1 << 0,
        PrimaryKeySet = 1 << 1,
        ValueSet = 1 << 2,
        AllFieldsSet = (KeySet | PrimaryKeySet | ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*DataEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class DataEntry;
    public:

        Builder<STATE | KeySet>& setKey(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & KeySet), property_key_already_set);
            m_result->setObject(ASCIILiteral("key"), value);
            return castState<KeySet>();
        }

        Builder<STATE | PrimaryKeySet>& setPrimaryKey(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & PrimaryKeySet), property_primaryKey_already_set);
            m_result->setObject(ASCIILiteral("primaryKey"), value);
            return castState<PrimaryKeySet>();
        }

        Builder<STATE | ValueSet>& setValue(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Ref<DataEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(DataEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<DataEntry>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<DataEntry> result = DataEntry::create()
     *     .setKey(...)
     *     .setPrimaryKey(...)
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Key path. */
class KeyPath : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating KeyPath.
    enum class Type {
        Null = 90,
        String = 88,
        Array = 89,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*KeyPath*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class KeyPath;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<KeyPath> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(KeyPath) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<KeyPath>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<KeyPath> result = KeyPath::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setString(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("string"), value);
    }

    void setArray(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("array"), WTFMove(value));
    }
};

} // IndexedDB
#endif // ENABLE(INDEXED_DATABASE)

namespace LayerTree {
/* A rectangle. */
class IntRect : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        WidthSet = 1 << 2,
        HeightSet = 1 << 3,
        AllFieldsSet = (XSet | YSet | WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*IntRect*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class IntRect;
    public:

        Builder<STATE | XSet>& setX(int value)
        {
            COMPILE_ASSERT(!(STATE & XSet), property_x_already_set);
            m_result->setInteger(ASCIILiteral("x"), value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(int value)
        {
            COMPILE_ASSERT(!(STATE & YSet), property_y_already_set);
            m_result->setInteger(ASCIILiteral("y"), value);
            return castState<YSet>();
        }

        Builder<STATE | WidthSet>& setWidth(int value)
        {
            COMPILE_ASSERT(!(STATE & WidthSet), property_width_already_set);
            m_result->setInteger(ASCIILiteral("width"), value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(int value)
        {
            COMPILE_ASSERT(!(STATE & HeightSet), property_height_already_set);
            m_result->setInteger(ASCIILiteral("height"), value);
            return castState<HeightSet>();
        }

        Ref<IntRect> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(IntRect) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<IntRect>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<IntRect> result = IntRect::create()
     *     .setX(...)
     *     .setY(...)
     *     .setWidth(...)
     *     .setHeight(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Information about a compositing layer. */
class Layer : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LayerIdSet = 1 << 0,
        NodeIdSet = 1 << 1,
        BoundsSet = 1 << 2,
        PaintCountSet = 1 << 3,
        MemorySet = 1 << 4,
        CompositedBoundsSet = 1 << 5,
        AllFieldsSet = (LayerIdSet | NodeIdSet | BoundsSet | PaintCountSet | MemorySet | CompositedBoundsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Layer*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Layer;
    public:

        Builder<STATE | LayerIdSet>& setLayerId(const Inspector::Protocol::LayerTree::LayerId& value)
        {
            COMPILE_ASSERT(!(STATE & LayerIdSet), property_layerId_already_set);
            m_result->setString(ASCIILiteral("layerId"), value);
            return castState<LayerIdSet>();
        }

        Builder<STATE | NodeIdSet>& setNodeId(int value)
        {
            COMPILE_ASSERT(!(STATE & NodeIdSet), property_nodeId_already_set);
            m_result->setInteger(ASCIILiteral("nodeId"), value);
            return castState<NodeIdSet>();
        }

        Builder<STATE | BoundsSet>& setBounds(RefPtr<Inspector::Protocol::LayerTree::IntRect> value)
        {
            COMPILE_ASSERT(!(STATE & BoundsSet), property_bounds_already_set);
            m_result->setObject(ASCIILiteral("bounds"), value);
            return castState<BoundsSet>();
        }

        Builder<STATE | PaintCountSet>& setPaintCount(int value)
        {
            COMPILE_ASSERT(!(STATE & PaintCountSet), property_paintCount_already_set);
            m_result->setInteger(ASCIILiteral("paintCount"), value);
            return castState<PaintCountSet>();
        }

        Builder<STATE | MemorySet>& setMemory(int value)
        {
            COMPILE_ASSERT(!(STATE & MemorySet), property_memory_already_set);
            m_result->setInteger(ASCIILiteral("memory"), value);
            return castState<MemorySet>();
        }

        Builder<STATE | CompositedBoundsSet>& setCompositedBounds(RefPtr<Inspector::Protocol::LayerTree::IntRect> value)
        {
            COMPILE_ASSERT(!(STATE & CompositedBoundsSet), property_compositedBounds_already_set);
            m_result->setObject(ASCIILiteral("compositedBounds"), value);
            return castState<CompositedBoundsSet>();
        }

        Ref<Layer> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Layer) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Layer>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Layer> result = Layer::create()
     *     .setLayerId(...)
     *     .setNodeId(...)
     *     .setBounds(...)
     *     .setPaintCount(...)
     *     .setMemory(...)
     *     .setCompositedBounds(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setIsInShadowTree(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isInShadowTree"), value);
    }

    void setIsReflection(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isReflection"), value);
    }

    void setIsGeneratedContent(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isGeneratedContent"), value);
    }

    void setIsAnonymous(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isAnonymous"), value);
    }

    void setPseudoElementId(const Inspector::Protocol::LayerTree::PseudoElementId& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("pseudoElementId"), value);
    }

    void setPseudoElement(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("pseudoElement"), value);
    }
};

/* An object containing the reasons why the layer was composited as properties. */
class CompositingReasons : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CompositingReasons*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CompositingReasons;
    public:

        Ref<CompositingReasons> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CompositingReasons) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CompositingReasons>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CompositingReasons> result = CompositingReasons::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setTransform3D(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("transform3D"), value);
    }

    void setVideo(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("video"), value);
    }

    void setCanvas(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("canvas"), value);
    }

    void setPlugin(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("plugin"), value);
    }

    void setIFrame(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("iFrame"), value);
    }

    void setBackfaceVisibilityHidden(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("backfaceVisibilityHidden"), value);
    }

    void setClipsCompositingDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("clipsCompositingDescendants"), value);
    }

    void setAnimation(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("animation"), value);
    }

    void setFilters(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("filters"), value);
    }

    void setPositionFixed(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("positionFixed"), value);
    }

    void setPositionSticky(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("positionSticky"), value);
    }

    void setOverflowScrollingTouch(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("overflowScrollingTouch"), value);
    }

    void setStacking(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("stacking"), value);
    }

    void setOverlap(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("overlap"), value);
    }

    void setNegativeZIndexChildren(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("negativeZIndexChildren"), value);
    }

    void setTransformWithCompositedDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("transformWithCompositedDescendants"), value);
    }

    void setOpacityWithCompositedDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("opacityWithCompositedDescendants"), value);
    }

    void setMaskWithCompositedDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("maskWithCompositedDescendants"), value);
    }

    void setReflectionWithCompositedDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("reflectionWithCompositedDescendants"), value);
    }

    void setFilterWithCompositedDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("filterWithCompositedDescendants"), value);
    }

    void setBlendingWithCompositedDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("blendingWithCompositedDescendants"), value);
    }

    void setIsolatesCompositedBlendingDescendants(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isolatesCompositedBlendingDescendants"), value);
    }

    void setPerspective(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("perspective"), value);
    }

    void setPreserve3D(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("preserve3D"), value);
    }

    void setWillChange(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("willChange"), value);
    }

    void setRoot(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("root"), value);
    }

    void setBlending(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("blending"), value);
    }
};

} // LayerTree

#if ENABLE(RESOURCE_USAGE)
namespace Memory {
class Event : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TimestampSet = 1 << 0,
        CategoriesSet = 1 << 1,
        AllFieldsSet = (TimestampSet | CategoriesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Event*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Event;
    public:

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble(ASCIILiteral("timestamp"), value);
            return castState<TimestampSet>();
        }

        Builder<STATE | CategoriesSet>& setCategories(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Memory::CategoryData>> value)
        {
            COMPILE_ASSERT(!(STATE & CategoriesSet), property_categories_already_set);
            m_result->setArray(ASCIILiteral("categories"), value);
            return castState<CategoriesSet>();
        }

        Ref<Event> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Event) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Event>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Event> result = Event::create()
     *     .setTimestamp(...)
     *     .setCategories(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class CategoryData : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating CategoryData.
    enum class Type {
        Javascript = 19,
        JIT = 91,
        Images = 92,
        Layers = 93,
        Page = 63,
        Other = 30,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        SizeSet = 1 << 1,
        AllFieldsSet = (TypeSet | SizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CategoryData*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CategoryData;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | SizeSet>& setSize(double value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setDouble(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Ref<CategoryData> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CategoryData) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CategoryData>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CategoryData> result = CategoryData::create()
     *     .setType(...)
     *     .setSize(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Memory
#endif // ENABLE(RESOURCE_USAGE)

namespace Network {
/* Timing information for the request. */
class ResourceTiming : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartTimeSet = 1 << 0,
        DomainLookupStartSet = 1 << 1,
        DomainLookupEndSet = 1 << 2,
        ConnectStartSet = 1 << 3,
        ConnectEndSet = 1 << 4,
        SecureConnectionStartSet = 1 << 5,
        RequestStartSet = 1 << 6,
        ResponseStartSet = 1 << 7,
        AllFieldsSet = (StartTimeSet | DomainLookupStartSet | DomainLookupEndSet | ConnectStartSet | ConnectEndSet | SecureConnectionStartSet | RequestStartSet | ResponseStartSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ResourceTiming*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ResourceTiming;
    public:

        Builder<STATE | StartTimeSet>& setStartTime(double value)
        {
            COMPILE_ASSERT(!(STATE & StartTimeSet), property_startTime_already_set);
            m_result->setDouble(ASCIILiteral("startTime"), value);
            return castState<StartTimeSet>();
        }

        Builder<STATE | DomainLookupStartSet>& setDomainLookupStart(double value)
        {
            COMPILE_ASSERT(!(STATE & DomainLookupStartSet), property_domainLookupStart_already_set);
            m_result->setDouble(ASCIILiteral("domainLookupStart"), value);
            return castState<DomainLookupStartSet>();
        }

        Builder<STATE | DomainLookupEndSet>& setDomainLookupEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & DomainLookupEndSet), property_domainLookupEnd_already_set);
            m_result->setDouble(ASCIILiteral("domainLookupEnd"), value);
            return castState<DomainLookupEndSet>();
        }

        Builder<STATE | ConnectStartSet>& setConnectStart(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectStartSet), property_connectStart_already_set);
            m_result->setDouble(ASCIILiteral("connectStart"), value);
            return castState<ConnectStartSet>();
        }

        Builder<STATE | ConnectEndSet>& setConnectEnd(double value)
        {
            COMPILE_ASSERT(!(STATE & ConnectEndSet), property_connectEnd_already_set);
            m_result->setDouble(ASCIILiteral("connectEnd"), value);
            return castState<ConnectEndSet>();
        }

        Builder<STATE | SecureConnectionStartSet>& setSecureConnectionStart(double value)
        {
            COMPILE_ASSERT(!(STATE & SecureConnectionStartSet), property_secureConnectionStart_already_set);
            m_result->setDouble(ASCIILiteral("secureConnectionStart"), value);
            return castState<SecureConnectionStartSet>();
        }

        Builder<STATE | RequestStartSet>& setRequestStart(double value)
        {
            COMPILE_ASSERT(!(STATE & RequestStartSet), property_requestStart_already_set);
            m_result->setDouble(ASCIILiteral("requestStart"), value);
            return castState<RequestStartSet>();
        }

        Builder<STATE | ResponseStartSet>& setResponseStart(double value)
        {
            COMPILE_ASSERT(!(STATE & ResponseStartSet), property_responseStart_already_set);
            m_result->setDouble(ASCIILiteral("responseStart"), value);
            return castState<ResponseStartSet>();
        }

        Ref<ResourceTiming> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ResourceTiming) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ResourceTiming>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ResourceTiming> result = ResourceTiming::create()
     *     .setStartTime(...)
     *     .setDomainLookupStart(...)
     *     .setDomainLookupEnd(...)
     *     .setConnectStart(...)
     *     .setConnectEnd(...)
     *     .setSecureConnectionStart(...)
     *     .setRequestStart(...)
     *     .setResponseStart(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* HTTP request data. */
class Request : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        MethodSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (UrlSet | MethodSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Request*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Request;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | MethodSet>& setMethod(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MethodSet), property_method_already_set);
            m_result->setString(ASCIILiteral("method"), value);
            return castState<MethodSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(RefPtr<JSON::Object> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        Ref<Request> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Request) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Request>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Request> result = Request::create()
     *     .setUrl(...)
     *     .setMethod(...)
     *     .setHeaders(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setPostData(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("postData"), value);
    }
};

/* HTTP response data. */
class Response : public JSON::Object {
public:
    // Named after property name 'source' while generating Response.
    enum class Source {
        Unknown = 94,
        Network = 20,
        MemoryCache = 95,
        DiskCache = 96,
        ServiceWorker = 97,
    }; // enum class Source
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        StatusSet = 1 << 1,
        StatusTextSet = 1 << 2,
        HeadersSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        SourceSet = 1 << 5,
        AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | SourceSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Response*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Response;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | StatusSet>& setStatus(int value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setInteger(ASCIILiteral("status"), value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString(ASCIILiteral("statusText"), value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(RefPtr<JSON::Object> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString(ASCIILiteral("mimeType"), value);
            return castState<MimeTypeSet>();
        }

        Builder<STATE | SourceSet>& setSource(Source value)
        {
            COMPILE_ASSERT(!(STATE & SourceSet), property_source_already_set);
            m_result->setString(ASCIILiteral("source"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<SourceSet>();
        }

        Ref<Response> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Response) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Response>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Response> result = Response::create()
     *     .setUrl(...)
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .setMimeType(...)
     *     .setSource(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setHeadersText(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("headersText"), value);
    }

    void setRequestHeaders(RefPtr<JSON::Object> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("requestHeaders"), WTFMove(value));
    }

    void setRequestHeadersText(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("requestHeadersText"), value);
    }

    void setTiming(RefPtr<Inspector::Protocol::Network::ResourceTiming> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("timing"), WTFMove(value));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* MimeType;
};

/* Network load metrics. */
class Metrics : public JSON::ObjectBase {
public:
    // Named after property name 'priority' while generating Metrics.
    enum class Priority {
        Low = 98,
        Medium = 99,
        High = 100,
    }; // enum class Priority
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Metrics*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Metrics;
    public:

        Ref<Metrics> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Metrics) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Metrics>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Metrics> result = Metrics::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setProtocol(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("protocol"), value);
    }

    void setPriority(Priority value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("priority"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setConnectionIdentifier(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("connectionIdentifier"), value);
    }

    void setRemoteAddress(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("remoteAddress"), value);
    }

    void setRequestHeaders(RefPtr<JSON::Object> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("requestHeaders"), WTFMove(value));
    }

    void setRequestHeaderBytesSent(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("requestHeaderBytesSent"), value);
    }

    void setRequestBodyBytesSent(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("requestBodyBytesSent"), value);
    }

    void setResponseHeaderBytesReceived(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("responseHeaderBytesReceived"), value);
    }

    void setResponseBodyBytesReceived(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("responseBodyBytesReceived"), value);
    }

    void setResponseBodyDecodedSize(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("responseBodyDecodedSize"), value);
    }
};

/* WebSocket request data. */
class WebSocketRequest : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        HeadersSet = 1 << 0,
        AllFieldsSet = (HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*WebSocketRequest*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class WebSocketRequest;
    public:

        Builder<STATE | HeadersSet>& setHeaders(RefPtr<JSON::Object> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        Ref<WebSocketRequest> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketRequest) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<WebSocketRequest>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<WebSocketRequest> result = WebSocketRequest::create()
     *     .setHeaders(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* WebSocket response data. */
class WebSocketResponse : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StatusSet = 1 << 0,
        StatusTextSet = 1 << 1,
        HeadersSet = 1 << 2,
        AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*WebSocketResponse*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class WebSocketResponse;
    public:

        Builder<STATE | StatusSet>& setStatus(int value)
        {
            COMPILE_ASSERT(!(STATE & StatusSet), property_status_already_set);
            m_result->setInteger(ASCIILiteral("status"), value);
            return castState<StatusSet>();
        }

        Builder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            COMPILE_ASSERT(!(STATE & StatusTextSet), property_statusText_already_set);
            m_result->setString(ASCIILiteral("statusText"), value);
            return castState<StatusTextSet>();
        }

        Builder<STATE | HeadersSet>& setHeaders(RefPtr<JSON::Object> value)
        {
            COMPILE_ASSERT(!(STATE & HeadersSet), property_headers_already_set);
            m_result->setObject(ASCIILiteral("headers"), value);
            return castState<HeadersSet>();
        }

        Ref<WebSocketResponse> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketResponse) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<WebSocketResponse>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<WebSocketResponse> result = WebSocketResponse::create()
     *     .setStatus(...)
     *     .setStatusText(...)
     *     .setHeaders(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* WebSocket frame data. */
class WebSocketFrame : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        OpcodeSet = 1 << 0,
        MaskSet = 1 << 1,
        PayloadDataSet = 1 << 2,
        PayloadLengthSet = 1 << 3,
        AllFieldsSet = (OpcodeSet | MaskSet | PayloadDataSet | PayloadLengthSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*WebSocketFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class WebSocketFrame;
    public:

        Builder<STATE | OpcodeSet>& setOpcode(double value)
        {
            COMPILE_ASSERT(!(STATE & OpcodeSet), property_opcode_already_set);
            m_result->setDouble(ASCIILiteral("opcode"), value);
            return castState<OpcodeSet>();
        }

        Builder<STATE | MaskSet>& setMask(bool value)
        {
            COMPILE_ASSERT(!(STATE & MaskSet), property_mask_already_set);
            m_result->setBoolean(ASCIILiteral("mask"), value);
            return castState<MaskSet>();
        }

        Builder<STATE | PayloadDataSet>& setPayloadData(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PayloadDataSet), property_payloadData_already_set);
            m_result->setString(ASCIILiteral("payloadData"), value);
            return castState<PayloadDataSet>();
        }

        Builder<STATE | PayloadLengthSet>& setPayloadLength(double value)
        {
            COMPILE_ASSERT(!(STATE & PayloadLengthSet), property_payloadLength_already_set);
            m_result->setDouble(ASCIILiteral("payloadLength"), value);
            return castState<PayloadLengthSet>();
        }

        Ref<WebSocketFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(WebSocketFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<WebSocketFrame>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<WebSocketFrame> result = WebSocketFrame::create()
     *     .setOpcode(...)
     *     .setMask(...)
     *     .setPayloadData(...)
     *     .setPayloadLength(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Information about the cached resource. */
class CachedResource : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        BodySizeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | BodySizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CachedResource*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CachedResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(Inspector::Protocol::Page::ResourceType value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | BodySizeSet>& setBodySize(double value)
        {
            COMPILE_ASSERT(!(STATE & BodySizeSet), property_bodySize_already_set);
            m_result->setDouble(ASCIILiteral("bodySize"), value);
            return castState<BodySizeSet>();
        }

        Ref<CachedResource> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CachedResource) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CachedResource>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CachedResource> result = CachedResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setBodySize(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setResponse(RefPtr<Inspector::Protocol::Network::Response> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("response"), WTFMove(value));
    }

    void setSourceMapURL(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("sourceMapURL"), value);
    }
};

/* Information about the request initiator. */
class Initiator : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating Initiator.
    enum class Type {
        Parser = 112,
        Script = 113,
        Other = 30,
    }; // enum class Type
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Initiator*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Initiator;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<Initiator> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Initiator) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Initiator>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Initiator> result = Initiator::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setStackTrace(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Console::CallFrame>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("stackTrace"), WTFMove(value));
    }

    void setUrl(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("url"), value);
    }

    void setLineNumber(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("lineNumber"), value);
    }
};

} // Network

namespace OverlayTypes {
class Point : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        AllFieldsSet = (XSet | YSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Point*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Point;
    public:

        Builder<STATE | XSet>& setX(double value)
        {
            COMPILE_ASSERT(!(STATE & XSet), property_x_already_set);
            m_result->setDouble(ASCIILiteral("x"), value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(double value)
        {
            COMPILE_ASSERT(!(STATE & YSet), property_y_already_set);
            m_result->setDouble(ASCIILiteral("y"), value);
            return castState<YSet>();
        }

        Ref<Point> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Point) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Point>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Point> result = Point::create()
     *     .setX(...)
     *     .setY(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class Size : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        WidthSet = 1 << 0,
        HeightSet = 1 << 1,
        AllFieldsSet = (WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Size*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Size;
    public:

        Builder<STATE | WidthSet>& setWidth(int value)
        {
            COMPILE_ASSERT(!(STATE & WidthSet), property_width_already_set);
            m_result->setInteger(ASCIILiteral("width"), value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(int value)
        {
            COMPILE_ASSERT(!(STATE & HeightSet), property_height_already_set);
            m_result->setInteger(ASCIILiteral("height"), value);
            return castState<HeightSet>();
        }

        Ref<Size> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Size) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Size>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Size> result = Size::create()
     *     .setWidth(...)
     *     .setHeight(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* A rectangle specified by a reference coordinate and width/height offsets. */
class Rect : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        XSet = 1 << 0,
        YSet = 1 << 1,
        WidthSet = 1 << 2,
        HeightSet = 1 << 3,
        AllFieldsSet = (XSet | YSet | WidthSet | HeightSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Rect*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Rect;
    public:

        Builder<STATE | XSet>& setX(double value)
        {
            COMPILE_ASSERT(!(STATE & XSet), property_x_already_set);
            m_result->setDouble(ASCIILiteral("x"), value);
            return castState<XSet>();
        }

        Builder<STATE | YSet>& setY(double value)
        {
            COMPILE_ASSERT(!(STATE & YSet), property_y_already_set);
            m_result->setDouble(ASCIILiteral("y"), value);
            return castState<YSet>();
        }

        Builder<STATE | WidthSet>& setWidth(double value)
        {
            COMPILE_ASSERT(!(STATE & WidthSet), property_width_already_set);
            m_result->setDouble(ASCIILiteral("width"), value);
            return castState<WidthSet>();
        }

        Builder<STATE | HeightSet>& setHeight(double value)
        {
            COMPILE_ASSERT(!(STATE & HeightSet), property_height_already_set);
            m_result->setDouble(ASCIILiteral("height"), value);
            return castState<HeightSet>();
        }

        Ref<Rect> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Rect) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Rect>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Rect> result = Rect::create()
     *     .setX(...)
     *     .setY(...)
     *     .setWidth(...)
     *     .setHeight(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class ShapeOutsideData : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        BoundsSet = 1 << 0,
        AllFieldsSet = (BoundsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ShapeOutsideData*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ShapeOutsideData;
    public:

        Builder<STATE | BoundsSet>& setBounds(RefPtr<Inspector::Protocol::OverlayTypes::Quad> value)
        {
            COMPILE_ASSERT(!(STATE & BoundsSet), property_bounds_already_set);
            m_result->setArray(ASCIILiteral("bounds"), value);
            return castState<BoundsSet>();
        }

        Ref<ShapeOutsideData> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ShapeOutsideData) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ShapeOutsideData>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ShapeOutsideData> result = ShapeOutsideData::create()
     *     .setBounds(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setShape(RefPtr<Inspector::Protocol::OverlayTypes::DisplayPath> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("shape"), WTFMove(value));
    }

    void setMarginShape(RefPtr<Inspector::Protocol::OverlayTypes::DisplayPath> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("marginShape"), WTFMove(value));
    }
};

/* Data that describes an element to be highlighted. */
class ElementData : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TagNameSet = 1 << 0,
        IdValueSet = 1 << 1,
        AllFieldsSet = (TagNameSet | IdValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ElementData*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ElementData;
    public:

        Builder<STATE | TagNameSet>& setTagName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TagNameSet), property_tagName_already_set);
            m_result->setString(ASCIILiteral("tagName"), value);
            return castState<TagNameSet>();
        }

        Builder<STATE | IdValueSet>& setIdValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & IdValueSet), property_idValue_already_set);
            m_result->setString(ASCIILiteral("idValue"), value);
            return castState<IdValueSet>();
        }

        Ref<ElementData> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ElementData) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ElementData>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ElementData> result = ElementData::create()
     *     .setTagName(...)
     *     .setIdValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setClasses(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("classes"), WTFMove(value));
    }

    void setSize(RefPtr<Inspector::Protocol::OverlayTypes::Size> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("size"), WTFMove(value));
    }

    void setRole(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("role"), value);
    }

    void setPseudoElement(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("pseudoElement"), value);
    }

    void setShapeOutsideData(RefPtr<Inspector::Protocol::OverlayTypes::ShapeOutsideData> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("shapeOutsideData"), WTFMove(value));
    }
};

/* Data required to highlight multiple quads. */
class FragmentHighlightData : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        QuadsSet = 1 << 0,
        ContentColorSet = 1 << 1,
        ContentOutlineColorSet = 1 << 2,
        PaddingColorSet = 1 << 3,
        BorderColorSet = 1 << 4,
        MarginColorSet = 1 << 5,
        AllFieldsSet = (QuadsSet | ContentColorSet | ContentOutlineColorSet | PaddingColorSet | BorderColorSet | MarginColorSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FragmentHighlightData*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FragmentHighlightData;
    public:

        Builder<STATE | QuadsSet>& setQuads(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::OverlayTypes::Quad>> value)
        {
            COMPILE_ASSERT(!(STATE & QuadsSet), property_quads_already_set);
            m_result->setArray(ASCIILiteral("quads"), value);
            return castState<QuadsSet>();
        }

        Builder<STATE | ContentColorSet>& setContentColor(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ContentColorSet), property_contentColor_already_set);
            m_result->setString(ASCIILiteral("contentColor"), value);
            return castState<ContentColorSet>();
        }

        Builder<STATE | ContentOutlineColorSet>& setContentOutlineColor(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ContentOutlineColorSet), property_contentOutlineColor_already_set);
            m_result->setString(ASCIILiteral("contentOutlineColor"), value);
            return castState<ContentOutlineColorSet>();
        }

        Builder<STATE | PaddingColorSet>& setPaddingColor(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PaddingColorSet), property_paddingColor_already_set);
            m_result->setString(ASCIILiteral("paddingColor"), value);
            return castState<PaddingColorSet>();
        }

        Builder<STATE | BorderColorSet>& setBorderColor(const String& value)
        {
            COMPILE_ASSERT(!(STATE & BorderColorSet), property_borderColor_already_set);
            m_result->setString(ASCIILiteral("borderColor"), value);
            return castState<BorderColorSet>();
        }

        Builder<STATE | MarginColorSet>& setMarginColor(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MarginColorSet), property_marginColor_already_set);
            m_result->setString(ASCIILiteral("marginColor"), value);
            return castState<MarginColorSet>();
        }

        Ref<FragmentHighlightData> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FragmentHighlightData) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<FragmentHighlightData>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FragmentHighlightData> result = FragmentHighlightData::create()
     *     .setQuads(...)
     *     .setContentColor(...)
     *     .setContentOutlineColor(...)
     *     .setPaddingColor(...)
     *     .setBorderColor(...)
     *     .setMarginColor(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Data required to highlight a DOM node. */
class NodeHighlightData : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ScrollOffsetSet = 1 << 0,
        FragmentsSet = 1 << 1,
        AllFieldsSet = (ScrollOffsetSet | FragmentsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*NodeHighlightData*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class NodeHighlightData;
    public:

        Builder<STATE | ScrollOffsetSet>& setScrollOffset(RefPtr<Inspector::Protocol::OverlayTypes::Point> value)
        {
            COMPILE_ASSERT(!(STATE & ScrollOffsetSet), property_scrollOffset_already_set);
            m_result->setObject(ASCIILiteral("scrollOffset"), value);
            return castState<ScrollOffsetSet>();
        }

        Builder<STATE | FragmentsSet>& setFragments(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::OverlayTypes::FragmentHighlightData>> value)
        {
            COMPILE_ASSERT(!(STATE & FragmentsSet), property_fragments_already_set);
            m_result->setArray(ASCIILiteral("fragments"), value);
            return castState<FragmentsSet>();
        }

        Ref<NodeHighlightData> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(NodeHighlightData) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<NodeHighlightData>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<NodeHighlightData> result = NodeHighlightData::create()
     *     .setScrollOffset(...)
     *     .setFragments(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setElementData(RefPtr<Inspector::Protocol::OverlayTypes::ElementData> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("elementData"), WTFMove(value));
    }
};

/* Data required to configure the overlay's size and scaling behavior. */
class OverlayConfiguration : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        DeviceScaleFactorSet = 1 << 0,
        ViewportSizeSet = 1 << 1,
        FrameViewFullSizeSet = 1 << 2,
        AllFieldsSet = (DeviceScaleFactorSet | ViewportSizeSet | FrameViewFullSizeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*OverlayConfiguration*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class OverlayConfiguration;
    public:

        Builder<STATE | DeviceScaleFactorSet>& setDeviceScaleFactor(double value)
        {
            COMPILE_ASSERT(!(STATE & DeviceScaleFactorSet), property_deviceScaleFactor_already_set);
            m_result->setDouble(ASCIILiteral("deviceScaleFactor"), value);
            return castState<DeviceScaleFactorSet>();
        }

        Builder<STATE | ViewportSizeSet>& setViewportSize(RefPtr<Inspector::Protocol::OverlayTypes::Size> value)
        {
            COMPILE_ASSERT(!(STATE & ViewportSizeSet), property_viewportSize_already_set);
            m_result->setObject(ASCIILiteral("viewportSize"), value);
            return castState<ViewportSizeSet>();
        }

        Builder<STATE | FrameViewFullSizeSet>& setFrameViewFullSize(RefPtr<Inspector::Protocol::OverlayTypes::Size> value)
        {
            COMPILE_ASSERT(!(STATE & FrameViewFullSizeSet), property_frameViewFullSize_already_set);
            m_result->setObject(ASCIILiteral("frameViewFullSize"), value);
            return castState<FrameViewFullSizeSet>();
        }

        Ref<OverlayConfiguration> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(OverlayConfiguration) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<OverlayConfiguration>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<OverlayConfiguration> result = OverlayConfiguration::create()
     *     .setDeviceScaleFactor(...)
     *     .setViewportSize(...)
     *     .setFrameViewFullSize(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // OverlayTypes

namespace Page {
/* Resource type as it was perceived by the rendering engine. */
enum class ResourceType {
    Document = 101,
    Stylesheet = 102,
    Image = 103,
    Font = 104,
    Script = 105,
    XHR = 106,
    Fetch = 107,
    Ping = 108,
    Beacon = 109,
    WebSocket = 110,
    Other = 111,
}; // enum class ResourceType
/* Coordinate system used by supplied coordinates. */
enum class CoordinateSystem {
    Viewport = 114,
    Page = 115,
}; // enum class CoordinateSystem
/* Information about the Frame on the page. */
class Frame : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        LoaderIdSet = 1 << 1,
        UrlSet = 1 << 2,
        SecurityOriginSet = 1 << 3,
        MimeTypeSet = 1 << 4,
        AllFieldsSet = (IdSet | LoaderIdSet | UrlSet | SecurityOriginSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Frame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Frame;
    public:

        Builder<STATE | IdSet>& setId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setString(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | LoaderIdSet>& setLoaderId(const Inspector::Protocol::Network::LoaderId& value)
        {
            COMPILE_ASSERT(!(STATE & LoaderIdSet), property_loaderId_already_set);
            m_result->setString(ASCIILiteral("loaderId"), value);
            return castState<LoaderIdSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString(ASCIILiteral("securityOrigin"), value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString(ASCIILiteral("mimeType"), value);
            return castState<MimeTypeSet>();
        }

        Ref<Frame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Frame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Frame>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Frame> result = Frame::create()
     *     .setId(...)
     *     .setLoaderId(...)
     *     .setUrl(...)
     *     .setSecurityOrigin(...)
     *     .setMimeType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setParentId(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("parentId"), value);
    }

    void setName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("name"), value);
    }
};

class FrameResource : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        TypeSet = 1 << 1,
        MimeTypeSet = 1 << 2,
        AllFieldsSet = (UrlSet | TypeSet | MimeTypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FrameResource*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FrameResource;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | TypeSet>& setType(Inspector::Protocol::Page::ResourceType value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MimeTypeSet), property_mimeType_already_set);
            m_result->setString(ASCIILiteral("mimeType"), value);
            return castState<MimeTypeSet>();
        }

        Ref<FrameResource> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameResource) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<FrameResource>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FrameResource> result = FrameResource::create()
     *     .setUrl(...)
     *     .setType(...)
     *     .setMimeType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setFailed(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("failed"), value);
    }

    void setCanceled(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("canceled"), value);
    }

    void setSourceMapURL(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("sourceMapURL"), value);
    }

    void setTargetId(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("targetId"), value);
    }
};

/* Information about the Frame hierarchy along with their cached resources. */
class FrameResourceTree : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        FrameSet = 1 << 0,
        ResourcesSet = 1 << 1,
        AllFieldsSet = (FrameSet | ResourcesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*FrameResourceTree*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class FrameResourceTree;
    public:

        Builder<STATE | FrameSet>& setFrame(RefPtr<Inspector::Protocol::Page::Frame> value)
        {
            COMPILE_ASSERT(!(STATE & FrameSet), property_frame_already_set);
            m_result->setObject(ASCIILiteral("frame"), value);
            return castState<FrameSet>();
        }

        Builder<STATE | ResourcesSet>& setResources(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Page::FrameResource>> value)
        {
            COMPILE_ASSERT(!(STATE & ResourcesSet), property_resources_already_set);
            m_result->setArray(ASCIILiteral("resources"), value);
            return castState<ResourcesSet>();
        }

        Ref<FrameResourceTree> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(FrameResourceTree) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<FrameResourceTree>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<FrameResourceTree> result = FrameResourceTree::create()
     *     .setFrame(...)
     *     .setResources(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setChildFrames(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Page::FrameResourceTree>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("childFrames"), WTFMove(value));
    }
};

/* Search result for resource. */
class SearchResult : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        UrlSet = 1 << 0,
        FrameIdSet = 1 << 1,
        MatchesCountSet = 1 << 2,
        AllFieldsSet = (UrlSet | FrameIdSet | MatchesCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*SearchResult*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class SearchResult;
    public:

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::Protocol::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Builder<STATE | MatchesCountSet>& setMatchesCount(double value)
        {
            COMPILE_ASSERT(!(STATE & MatchesCountSet), property_matchesCount_already_set);
            m_result->setDouble(ASCIILiteral("matchesCount"), value);
            return castState<MatchesCountSet>();
        }

        Ref<SearchResult> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(SearchResult) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<SearchResult>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<SearchResult> result = SearchResult::create()
     *     .setUrl(...)
     *     .setFrameId(...)
     *     .setMatchesCount(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setRequestId(const Inspector::Protocol::Network::RequestId& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("requestId"), value);
    }
};

/* Cookie object */
class Cookie : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ValueSet = 1 << 1,
        DomainSet = 1 << 2,
        PathSet = 1 << 3,
        ExpiresSet = 1 << 4,
        SizeSet = 1 << 5,
        HttpOnlySet = 1 << 6,
        SecureSet = 1 << 7,
        SessionSet = 1 << 8,
        AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Cookie*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Cookie;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ValueSet>& setValue(const String& value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setString(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Builder<STATE | DomainSet>& setDomain(const String& value)
        {
            COMPILE_ASSERT(!(STATE & DomainSet), property_domain_already_set);
            m_result->setString(ASCIILiteral("domain"), value);
            return castState<DomainSet>();
        }

        Builder<STATE | PathSet>& setPath(const String& value)
        {
            COMPILE_ASSERT(!(STATE & PathSet), property_path_already_set);
            m_result->setString(ASCIILiteral("path"), value);
            return castState<PathSet>();
        }

        Builder<STATE | ExpiresSet>& setExpires(double value)
        {
            COMPILE_ASSERT(!(STATE & ExpiresSet), property_expires_already_set);
            m_result->setDouble(ASCIILiteral("expires"), value);
            return castState<ExpiresSet>();
        }

        Builder<STATE | SizeSet>& setSize(int value)
        {
            COMPILE_ASSERT(!(STATE & SizeSet), property_size_already_set);
            m_result->setInteger(ASCIILiteral("size"), value);
            return castState<SizeSet>();
        }

        Builder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            COMPILE_ASSERT(!(STATE & HttpOnlySet), property_httpOnly_already_set);
            m_result->setBoolean(ASCIILiteral("httpOnly"), value);
            return castState<HttpOnlySet>();
        }

        Builder<STATE | SecureSet>& setSecure(bool value)
        {
            COMPILE_ASSERT(!(STATE & SecureSet), property_secure_already_set);
            m_result->setBoolean(ASCIILiteral("secure"), value);
            return castState<SecureSet>();
        }

        Builder<STATE | SessionSet>& setSession(bool value)
        {
            COMPILE_ASSERT(!(STATE & SessionSet), property_session_already_set);
            m_result->setBoolean(ASCIILiteral("session"), value);
            return castState<SessionSet>();
        }

        Ref<Cookie> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Cookie) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Cookie>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Cookie> result = Cookie::create()
     *     .setName(...)
     *     .setValue(...)
     *     .setDomain(...)
     *     .setPath(...)
     *     .setExpires(...)
     *     .setSize(...)
     *     .setHttpOnly(...)
     *     .setSecure(...)
     *     .setSession(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Page

namespace Recording {
/* The type of the recording. */
enum class Type {
    Canvas2D = 12,
    CanvasWebGL = 116,
}; // enum class Type
/* Information about the initial state of the recorded object. */
class InitialState : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InitialState*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InitialState;
    public:

        Ref<InitialState> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InitialState) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<InitialState>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InitialState> result = InitialState::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setAttributes(RefPtr<JSON::Object> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("attributes"), WTFMove(value));
    }

    void setParameters(RefPtr<Inspector::Protocol::Array<JSON::Value>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("parameters"), WTFMove(value));
    }

    void setContent(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("content"), value);
    }
};

/* Container object for a single frame of the recording. */
class Frame : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ActionsSet = 1 << 0,
        AllFieldsSet = (ActionsSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Frame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Frame;
    public:

        Builder<STATE | ActionsSet>& setActions(RefPtr<Inspector::Protocol::Array<JSON::Value>> value)
        {
            COMPILE_ASSERT(!(STATE & ActionsSet), property_actions_already_set);
            m_result->setArray(ASCIILiteral("actions"), value);
            return castState<ActionsSet>();
        }

        Ref<Frame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Frame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Frame>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Frame> result = Frame::create()
     *     .setActions(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setDuration(double value)
    {
        JSON::ObjectBase::setDouble(ASCIILiteral("duration"), value);
    }

    void setIncomplete(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("incomplete"), value);
    }
};

class Recording : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        VersionSet = 1 << 0,
        TypeSet = 1 << 1,
        InitialStateSet = 1 << 2,
        DataSet = 1 << 3,
        AllFieldsSet = (VersionSet | TypeSet | InitialStateSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Recording*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Recording;
    public:

        Builder<STATE | VersionSet>& setVersion(int value)
        {
            COMPILE_ASSERT(!(STATE & VersionSet), property_version_already_set);
            m_result->setInteger(ASCIILiteral("version"), value);
            return castState<VersionSet>();
        }

        Builder<STATE | TypeSet>& setType(Inspector::Protocol::Recording::Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | InitialStateSet>& setInitialState(RefPtr<Inspector::Protocol::Recording::InitialState> value)
        {
            COMPILE_ASSERT(!(STATE & InitialStateSet), property_initialState_already_set);
            m_result->setObject(ASCIILiteral("initialState"), value);
            return castState<InitialStateSet>();
        }

        Builder<STATE | DataSet>& setData(RefPtr<Inspector::Protocol::Array<JSON::Value>> value)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setArray(ASCIILiteral("data"), value);
            return castState<DataSet>();
        }

        Ref<Recording> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Recording) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Recording>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Recording> result = Recording::create()
     *     .setVersion(...)
     *     .setType(...)
     *     .setInitialState(...)
     *     .setData(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Recording

namespace Runtime {
/* Mirror object referencing original JavaScript object. */
class RemoteObject : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating RemoteObject.
    enum class Type {
        Object = 117,
        Function = 118,
        Undefined = 119,
        String = 88,
        Number = 87,
        Boolean = 120,
        Symbol = 121,
    }; // enum class Type
    // Named after property name 'subtype' while generating RemoteObject.
    enum class Subtype {
        Array = 89,
        Null = 90,
        Node = 122,
        Regexp = 123,
        Date = 66,
        Error = 33,
        Map = 124,
        Set = 125,
        Weakmap = 126,
        Weakset = 127,
        Iterator = 128,
        Class = 129,
        Proxy = 130,
    }; // enum class Subtype
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        AllFieldsSet = (TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*RemoteObject*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class RemoteObject;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<RemoteObject> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(RemoteObject) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<RemoteObject>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<RemoteObject> result = RemoteObject::create()
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubtype(Subtype value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("subtype"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setClassName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("className"), value);
    }

    void setValue(RefPtr<JSON::Value> value)
    {
        JSON::ObjectBase::setValue(ASCIILiteral("value"), WTFMove(value));
    }

    void setDescription(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("description"), value);
    }

    void setObjectId(const Inspector::Protocol::Runtime::RemoteObjectId& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("objectId"), value);
    }

    void setSize(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("size"), value);
    }

    void setClassPrototype(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("classPrototype"), WTFMove(value));
    }

    void setPreview(RefPtr<Inspector::Protocol::Runtime::ObjectPreview> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("preview"), WTFMove(value));
    }
};

/* Object containing abbreviated remote object value. */
class ObjectPreview : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating ObjectPreview.
    enum class Type {
        Object = 117,
        Function = 118,
        Undefined = 119,
        String = 88,
        Number = 87,
        Boolean = 120,
        Symbol = 121,
    }; // enum class Type
    // Named after property name 'subtype' while generating ObjectPreview.
    enum class Subtype {
        Array = 89,
        Null = 90,
        Node = 122,
        Regexp = 123,
        Date = 66,
        Error = 33,
        Map = 124,
        Set = 125,
        Weakmap = 126,
        Weakset = 127,
        Iterator = 128,
        Class = 129,
        Proxy = 130,
    }; // enum class Subtype
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        LosslessSet = 1 << 1,
        AllFieldsSet = (TypeSet | LosslessSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ObjectPreview*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ObjectPreview;
    public:

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | LosslessSet>& setLossless(bool value)
        {
            COMPILE_ASSERT(!(STATE & LosslessSet), property_lossless_already_set);
            m_result->setBoolean(ASCIILiteral("lossless"), value);
            return castState<LosslessSet>();
        }

        Ref<ObjectPreview> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ObjectPreview) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ObjectPreview>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ObjectPreview> result = ObjectPreview::create()
     *     .setType(...)
     *     .setLossless(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubtype(Subtype value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("subtype"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setDescription(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("description"), value);
    }

    void setOverflow(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("overflow"), value);
    }

    void setProperties(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::PropertyPreview>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("properties"), WTFMove(value));
    }

    void setEntries(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::EntryPreview>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("entries"), WTFMove(value));
    }

    void setSize(int value)
    {
        JSON::ObjectBase::setInteger(ASCIILiteral("size"), value);
    }
};

class PropertyPreview : public JSON::ObjectBase {
public:
    // Named after property name 'type' while generating PropertyPreview.
    enum class Type {
        Object = 117,
        Function = 118,
        Undefined = 119,
        String = 88,
        Number = 87,
        Boolean = 120,
        Symbol = 121,
        Accessor = 131,
    }; // enum class Type
    // Named after property name 'subtype' while generating PropertyPreview.
    enum class Subtype {
        Array = 89,
        Null = 90,
        Node = 122,
        Regexp = 123,
        Date = 66,
        Error = 33,
        Map = 124,
        Set = 125,
        Weakmap = 126,
        Weakset = 127,
        Iterator = 128,
        Class = 129,
        Proxy = 130,
    }; // enum class Subtype
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        TypeSet = 1 << 1,
        AllFieldsSet = (NameSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PropertyPreview*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class PropertyPreview;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | TypeSet>& setType(Type value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<PropertyPreview> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PropertyPreview) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<PropertyPreview>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PropertyPreview> result = PropertyPreview::create()
     *     .setName(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setSubtype(Subtype value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("subtype"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
    }

    void setValue(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("value"), value);
    }

    void setValuePreview(RefPtr<Inspector::Protocol::Runtime::ObjectPreview> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("valuePreview"), WTFMove(value));
    }

    void setInternal(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("internal"), value);
    }
};

class EntryPreview : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*EntryPreview*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class EntryPreview;
    public:

        Builder<STATE | ValueSet>& setValue(RefPtr<Inspector::Protocol::Runtime::ObjectPreview> value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Ref<EntryPreview> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(EntryPreview) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<EntryPreview>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<EntryPreview> result = EntryPreview::create()
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setKey(RefPtr<Inspector::Protocol::Runtime::ObjectPreview> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("key"), WTFMove(value));
    }
};

class CollectionEntry : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        ValueSet = 1 << 0,
        AllFieldsSet = (ValueSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CollectionEntry*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CollectionEntry;
    public:

        Builder<STATE | ValueSet>& setValue(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
        {
            COMPILE_ASSERT(!(STATE & ValueSet), property_value_already_set);
            m_result->setObject(ASCIILiteral("value"), value);
            return castState<ValueSet>();
        }

        Ref<CollectionEntry> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CollectionEntry) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CollectionEntry>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CollectionEntry> result = CollectionEntry::create()
     *     .setValue(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setKey(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("key"), WTFMove(value));
    }
};

/* Object property descriptor. */
class PropertyDescriptor : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        ConfigurableSet = 1 << 1,
        EnumerableSet = 1 << 2,
        AllFieldsSet = (NameSet | ConfigurableSet | EnumerableSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*PropertyDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class PropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | ConfigurableSet>& setConfigurable(bool value)
        {
            COMPILE_ASSERT(!(STATE & ConfigurableSet), property_configurable_already_set);
            m_result->setBoolean(ASCIILiteral("configurable"), value);
            return castState<ConfigurableSet>();
        }

        Builder<STATE | EnumerableSet>& setEnumerable(bool value)
        {
            COMPILE_ASSERT(!(STATE & EnumerableSet), property_enumerable_already_set);
            m_result->setBoolean(ASCIILiteral("enumerable"), value);
            return castState<EnumerableSet>();
        }

        Ref<PropertyDescriptor> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(PropertyDescriptor) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<PropertyDescriptor>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<PropertyDescriptor> result = PropertyDescriptor::create()
     *     .setName(...)
     *     .setConfigurable(...)
     *     .setEnumerable(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("value"), WTFMove(value));
    }

    void setWritable(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("writable"), value);
    }

    void setGet(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("get"), WTFMove(value));
    }

    void setSet(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("set"), WTFMove(value));
    }

    void setWasThrown(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("wasThrown"), value);
    }

    void setIsOwn(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isOwn"), value);
    }

    void setSymbol(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("symbol"), WTFMove(value));
    }

    void setNativeGetter(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("nativeGetter"), value);
    }
};

/* Object internal property descriptor. This property isn't normally visible in JavaScript code. */
class InternalPropertyDescriptor : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        NameSet = 1 << 0,
        AllFieldsSet = (NameSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InternalPropertyDescriptor*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InternalPropertyDescriptor;
    public:

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Ref<InternalPropertyDescriptor> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InternalPropertyDescriptor) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<InternalPropertyDescriptor>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InternalPropertyDescriptor> result = InternalPropertyDescriptor::create()
     *     .setName(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(RefPtr<Inspector::Protocol::Runtime::RemoteObject> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("value"), WTFMove(value));
    }
};

/* Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified. */
class CallArgument : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*CallArgument*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class CallArgument;
    public:

        Ref<CallArgument> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(CallArgument) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<CallArgument>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<CallArgument> result = CallArgument::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setValue(RefPtr<JSON::Value> value)
    {
        JSON::ObjectBase::setValue(ASCIILiteral("value"), WTFMove(value));
    }

    void setObjectId(const Inspector::Protocol::Runtime::RemoteObjectId& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("objectId"), value);
    }
};

/* Description of an isolated world. */
class ExecutionContextDescription : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IdSet = 1 << 0,
        IsPageContextSet = 1 << 1,
        NameSet = 1 << 2,
        FrameIdSet = 1 << 3,
        AllFieldsSet = (IdSet | IsPageContextSet | NameSet | FrameIdSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ExecutionContextDescription*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ExecutionContextDescription;
    public:

        Builder<STATE | IdSet>& setId(int value)
        {
            COMPILE_ASSERT(!(STATE & IdSet), property_id_already_set);
            m_result->setInteger(ASCIILiteral("id"), value);
            return castState<IdSet>();
        }

        Builder<STATE | IsPageContextSet>& setIsPageContext(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsPageContextSet), property_isPageContext_already_set);
            m_result->setBoolean(ASCIILiteral("isPageContext"), value);
            return castState<IsPageContextSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | FrameIdSet>& setFrameId(const Inspector::Protocol::Network::FrameId& value)
        {
            COMPILE_ASSERT(!(STATE & FrameIdSet), property_frameId_already_set);
            m_result->setString(ASCIILiteral("frameId"), value);
            return castState<FrameIdSet>();
        }

        Ref<ExecutionContextDescription> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ExecutionContextDescription) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ExecutionContextDescription>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ExecutionContextDescription> result = ExecutionContextDescription::create()
     *     .setId(...)
     *     .setIsPageContext(...)
     *     .setName(...)
     *     .setFrameId(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Syntax error type: "none" for no error, "irrecoverable" for unrecoverable errors, "unterminated-literal" for when there is an unterminated literal, "recoverable" for when the expression is unfinished but valid so far. */
enum class SyntaxErrorType {
    None = 132,
    Irrecoverable = 133,
    UnterminatedLiteral = 134,
    Recoverable = 135,
}; // enum class SyntaxErrorType
/* Range of an error in source code. */
class ErrorRange : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartOffsetSet = 1 << 0,
        EndOffsetSet = 1 << 1,
        AllFieldsSet = (StartOffsetSet | EndOffsetSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ErrorRange*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ErrorRange;
    public:

        Builder<STATE | StartOffsetSet>& setStartOffset(int value)
        {
            COMPILE_ASSERT(!(STATE & StartOffsetSet), property_startOffset_already_set);
            m_result->setInteger(ASCIILiteral("startOffset"), value);
            return castState<StartOffsetSet>();
        }

        Builder<STATE | EndOffsetSet>& setEndOffset(int value)
        {
            COMPILE_ASSERT(!(STATE & EndOffsetSet), property_endOffset_already_set);
            m_result->setInteger(ASCIILiteral("endOffset"), value);
            return castState<EndOffsetSet>();
        }

        Ref<ErrorRange> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ErrorRange) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ErrorRange>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ErrorRange> result = ErrorRange::create()
     *     .setStartOffset(...)
     *     .setEndOffset(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class StructureDescription : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        AllFieldsSet = 0
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StructureDescription*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StructureDescription;
    public:

        Ref<StructureDescription> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StructureDescription) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<StructureDescription>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StructureDescription> result = StructureDescription::create()
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setFields(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("fields"), WTFMove(value));
    }

    void setOptionalFields(RefPtr<Inspector::Protocol::Array<String>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("optionalFields"), WTFMove(value));
    }

    void setConstructorName(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("constructorName"), value);
    }

    void setPrototypeStructure(RefPtr<Inspector::Protocol::Runtime::StructureDescription> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("prototypeStructure"), WTFMove(value));
    }

    void setIsImprecise(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isImprecise"), value);
    }
};

class TypeSet : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IsFunctionSet = 1 << 0,
        IsUndefinedSet = 1 << 1,
        IsNullSet = 1 << 2,
        IsBooleanSet = 1 << 3,
        IsIntegerSet = 1 << 4,
        IsNumberSet = 1 << 5,
        IsStringSet = 1 << 6,
        IsObjectSet = 1 << 7,
        IsSymbolSet = 1 << 8,
        AllFieldsSet = (IsFunctionSet | IsUndefinedSet | IsNullSet | IsBooleanSet | IsIntegerSet | IsNumberSet | IsStringSet | IsObjectSet | IsSymbolSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TypeSet*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TypeSet;
    public:

        Builder<STATE | IsFunctionSet>& setIsFunction(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsFunctionSet), property_isFunction_already_set);
            m_result->setBoolean(ASCIILiteral("isFunction"), value);
            return castState<IsFunctionSet>();
        }

        Builder<STATE | IsUndefinedSet>& setIsUndefined(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsUndefinedSet), property_isUndefined_already_set);
            m_result->setBoolean(ASCIILiteral("isUndefined"), value);
            return castState<IsUndefinedSet>();
        }

        Builder<STATE | IsNullSet>& setIsNull(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsNullSet), property_isNull_already_set);
            m_result->setBoolean(ASCIILiteral("isNull"), value);
            return castState<IsNullSet>();
        }

        Builder<STATE | IsBooleanSet>& setIsBoolean(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsBooleanSet), property_isBoolean_already_set);
            m_result->setBoolean(ASCIILiteral("isBoolean"), value);
            return castState<IsBooleanSet>();
        }

        Builder<STATE | IsIntegerSet>& setIsInteger(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsIntegerSet), property_isInteger_already_set);
            m_result->setBoolean(ASCIILiteral("isInteger"), value);
            return castState<IsIntegerSet>();
        }

        Builder<STATE | IsNumberSet>& setIsNumber(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsNumberSet), property_isNumber_already_set);
            m_result->setBoolean(ASCIILiteral("isNumber"), value);
            return castState<IsNumberSet>();
        }

        Builder<STATE | IsStringSet>& setIsString(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsStringSet), property_isString_already_set);
            m_result->setBoolean(ASCIILiteral("isString"), value);
            return castState<IsStringSet>();
        }

        Builder<STATE | IsObjectSet>& setIsObject(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsObjectSet), property_isObject_already_set);
            m_result->setBoolean(ASCIILiteral("isObject"), value);
            return castState<IsObjectSet>();
        }

        Builder<STATE | IsSymbolSet>& setIsSymbol(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsSymbolSet), property_isSymbol_already_set);
            m_result->setBoolean(ASCIILiteral("isSymbol"), value);
            return castState<IsSymbolSet>();
        }

        Ref<TypeSet> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TypeSet) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<TypeSet>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TypeSet> result = TypeSet::create()
     *     .setIsFunction(...)
     *     .setIsUndefined(...)
     *     .setIsNull(...)
     *     .setIsBoolean(...)
     *     .setIsInteger(...)
     *     .setIsNumber(...)
     *     .setIsString(...)
     *     .setIsObject(...)
     *     .setIsSymbol(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* Container for type information that has been gathered. */
class TypeDescription : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        IsValidSet = 1 << 0,
        AllFieldsSet = (IsValidSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TypeDescription*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TypeDescription;
    public:

        Builder<STATE | IsValidSet>& setIsValid(bool value)
        {
            COMPILE_ASSERT(!(STATE & IsValidSet), property_isValid_already_set);
            m_result->setBoolean(ASCIILiteral("isValid"), value);
            return castState<IsValidSet>();
        }

        Ref<TypeDescription> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TypeDescription) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<TypeDescription>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TypeDescription> result = TypeDescription::create()
     *     .setIsValid(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setLeastCommonAncestor(const String& value)
    {
        JSON::ObjectBase::setString(ASCIILiteral("leastCommonAncestor"), value);
    }

    void setTypeSet(RefPtr<Inspector::Protocol::Runtime::TypeSet> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("typeSet"), WTFMove(value));
    }

    void setStructures(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Runtime::StructureDescription>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("structures"), WTFMove(value));
    }

    void setIsTruncated(bool value)
    {
        JSON::ObjectBase::setBoolean(ASCIILiteral("isTruncated"), value);
    }
};

/* Describes the location of an expression we want type information for. */
class TypeLocation : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TypeInformationDescriptorSet = 1 << 0,
        SourceIDSet = 1 << 1,
        DivotSet = 1 << 2,
        AllFieldsSet = (TypeInformationDescriptorSet | SourceIDSet | DivotSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TypeLocation*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TypeLocation;
    public:

        Builder<STATE | TypeInformationDescriptorSet>& setTypeInformationDescriptor(int value)
        {
            COMPILE_ASSERT(!(STATE & TypeInformationDescriptorSet), property_typeInformationDescriptor_already_set);
            m_result->setInteger(ASCIILiteral("typeInformationDescriptor"), value);
            return castState<TypeInformationDescriptorSet>();
        }

        Builder<STATE | SourceIDSet>& setSourceID(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SourceIDSet), property_sourceID_already_set);
            m_result->setString(ASCIILiteral("sourceID"), value);
            return castState<SourceIDSet>();
        }

        Builder<STATE | DivotSet>& setDivot(int value)
        {
            COMPILE_ASSERT(!(STATE & DivotSet), property_divot_already_set);
            m_result->setInteger(ASCIILiteral("divot"), value);
            return castState<DivotSet>();
        }

        Ref<TypeLocation> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TypeLocation) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<TypeLocation>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TypeLocation> result = TypeLocation::create()
     *     .setTypeInformationDescriptor(...)
     *     .setSourceID(...)
     *     .setDivot(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

/* From Wikipedia: a basic block is a portion of the code within a program with only one entry point and only one exit point. This type gives the location of a basic block and if that basic block has executed. */
class BasicBlock : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartOffsetSet = 1 << 0,
        EndOffsetSet = 1 << 1,
        HasExecutedSet = 1 << 2,
        ExecutionCountSet = 1 << 3,
        AllFieldsSet = (StartOffsetSet | EndOffsetSet | HasExecutedSet | ExecutionCountSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*BasicBlock*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class BasicBlock;
    public:

        Builder<STATE | StartOffsetSet>& setStartOffset(int value)
        {
            COMPILE_ASSERT(!(STATE & StartOffsetSet), property_startOffset_already_set);
            m_result->setInteger(ASCIILiteral("startOffset"), value);
            return castState<StartOffsetSet>();
        }

        Builder<STATE | EndOffsetSet>& setEndOffset(int value)
        {
            COMPILE_ASSERT(!(STATE & EndOffsetSet), property_endOffset_already_set);
            m_result->setInteger(ASCIILiteral("endOffset"), value);
            return castState<EndOffsetSet>();
        }

        Builder<STATE | HasExecutedSet>& setHasExecuted(bool value)
        {
            COMPILE_ASSERT(!(STATE & HasExecutedSet), property_hasExecuted_already_set);
            m_result->setBoolean(ASCIILiteral("hasExecuted"), value);
            return castState<HasExecutedSet>();
        }

        Builder<STATE | ExecutionCountSet>& setExecutionCount(int value)
        {
            COMPILE_ASSERT(!(STATE & ExecutionCountSet), property_executionCount_already_set);
            m_result->setInteger(ASCIILiteral("executionCount"), value);
            return castState<ExecutionCountSet>();
        }

        Ref<BasicBlock> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(BasicBlock) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<BasicBlock>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<BasicBlock> result = BasicBlock::create()
     *     .setStartOffset(...)
     *     .setEndOffset(...)
     *     .setHasExecuted(...)
     *     .setExecutionCount(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // Runtime

namespace ScriptProfiler {
/*  */
enum class EventType {
    API = 136,
    Microtask = 137,
    Other = 111,
}; // enum class EventType
class Event : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StartTimeSet = 1 << 0,
        EndTimeSet = 1 << 1,
        TypeSet = 1 << 2,
        AllFieldsSet = (StartTimeSet | EndTimeSet | TypeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Event*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Event;
    public:

        Builder<STATE | StartTimeSet>& setStartTime(double value)
        {
            COMPILE_ASSERT(!(STATE & StartTimeSet), property_startTime_already_set);
            m_result->setDouble(ASCIILiteral("startTime"), value);
            return castState<StartTimeSet>();
        }

        Builder<STATE | EndTimeSet>& setEndTime(double value)
        {
            COMPILE_ASSERT(!(STATE & EndTimeSet), property_endTime_already_set);
            m_result->setDouble(ASCIILiteral("endTime"), value);
            return castState<EndTimeSet>();
        }

        Builder<STATE | TypeSet>& setType(Inspector::Protocol::ScriptProfiler::EventType value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Ref<Event> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Event) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Event>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Event> result = Event::create()
     *     .setStartTime(...)
     *     .setEndTime(...)
     *     .setType(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class ExpressionLocation : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        LineSet = 1 << 0,
        ColumnSet = 1 << 1,
        AllFieldsSet = (LineSet | ColumnSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*ExpressionLocation*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class ExpressionLocation;
    public:

        Builder<STATE | LineSet>& setLine(int value)
        {
            COMPILE_ASSERT(!(STATE & LineSet), property_line_already_set);
            m_result->setInteger(ASCIILiteral("line"), value);
            return castState<LineSet>();
        }

        Builder<STATE | ColumnSet>& setColumn(int value)
        {
            COMPILE_ASSERT(!(STATE & ColumnSet), property_column_already_set);
            m_result->setInteger(ASCIILiteral("column"), value);
            return castState<ColumnSet>();
        }

        Ref<ExpressionLocation> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(ExpressionLocation) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<ExpressionLocation>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<ExpressionLocation> result = ExpressionLocation::create()
     *     .setLine(...)
     *     .setColumn(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class StackFrame : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        SourceIDSet = 1 << 0,
        NameSet = 1 << 1,
        LineSet = 1 << 2,
        ColumnSet = 1 << 3,
        UrlSet = 1 << 4,
        AllFieldsSet = (SourceIDSet | NameSet | LineSet | ColumnSet | UrlSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackFrame*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StackFrame;
    public:

        Builder<STATE | SourceIDSet>& setSourceID(const Inspector::Protocol::Debugger::ScriptId& value)
        {
            COMPILE_ASSERT(!(STATE & SourceIDSet), property_sourceID_already_set);
            m_result->setString(ASCIILiteral("sourceID"), value);
            return castState<SourceIDSet>();
        }

        Builder<STATE | NameSet>& setName(const String& value)
        {
            COMPILE_ASSERT(!(STATE & NameSet), property_name_already_set);
            m_result->setString(ASCIILiteral("name"), value);
            return castState<NameSet>();
        }

        Builder<STATE | LineSet>& setLine(int value)
        {
            COMPILE_ASSERT(!(STATE & LineSet), property_line_already_set);
            m_result->setInteger(ASCIILiteral("line"), value);
            return castState<LineSet>();
        }

        Builder<STATE | ColumnSet>& setColumn(int value)
        {
            COMPILE_ASSERT(!(STATE & ColumnSet), property_column_already_set);
            m_result->setInteger(ASCIILiteral("column"), value);
            return castState<ColumnSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Ref<StackFrame> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StackFrame) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<StackFrame>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackFrame> result = StackFrame::create()
     *     .setSourceID(...)
     *     .setName(...)
     *     .setLine(...)
     *     .setColumn(...)
     *     .setUrl(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setExpressionLocation(RefPtr<Inspector::Protocol::ScriptProfiler::ExpressionLocation> value)
    {
        JSON::ObjectBase::setObject(ASCIILiteral("expressionLocation"), WTFMove(value));
    }
};

class StackTrace : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TimestampSet = 1 << 0,
        StackFramesSet = 1 << 1,
        AllFieldsSet = (TimestampSet | StackFramesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*StackTrace*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class StackTrace;
    public:

        Builder<STATE | TimestampSet>& setTimestamp(double value)
        {
            COMPILE_ASSERT(!(STATE & TimestampSet), property_timestamp_already_set);
            m_result->setDouble(ASCIILiteral("timestamp"), value);
            return castState<TimestampSet>();
        }

        Builder<STATE | StackFramesSet>& setStackFrames(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::ScriptProfiler::StackFrame>> value)
        {
            COMPILE_ASSERT(!(STATE & StackFramesSet), property_stackFrames_already_set);
            m_result->setArray(ASCIILiteral("stackFrames"), value);
            return castState<StackFramesSet>();
        }

        Ref<StackTrace> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(StackTrace) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<StackTrace>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<StackTrace> result = StackTrace::create()
     *     .setTimestamp(...)
     *     .setStackFrames(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

class Samples : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        StackTracesSet = 1 << 0,
        AllFieldsSet = (StackTracesSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Samples*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Samples;
    public:

        Builder<STATE | StackTracesSet>& setStackTraces(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::ScriptProfiler::StackTrace>> value)
        {
            COMPILE_ASSERT(!(STATE & StackTracesSet), property_stackTraces_already_set);
            m_result->setArray(ASCIILiteral("stackTraces"), value);
            return castState<StackTracesSet>();
        }

        Ref<Samples> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Samples) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Samples>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Samples> result = Samples::create()
     *     .setStackTraces(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // ScriptProfiler

namespace ServiceWorker {
/* ServiceWorker metadata and initial state. */
class InitializationInfo : public JSON::ObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        TargetIdSet = 1 << 0,
        SecurityOriginSet = 1 << 1,
        UrlSet = 1 << 2,
        AllFieldsSet = (TargetIdSet | SecurityOriginSet | UrlSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*InitializationInfo*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class InitializationInfo;
    public:

        Builder<STATE | TargetIdSet>& setTargetId(const String& value)
        {
            COMPILE_ASSERT(!(STATE & TargetIdSet), property_targetId_already_set);
            m_result->setString(ASCIILiteral("targetId"), value);
            return castState<TargetIdSet>();
        }

        Builder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            COMPILE_ASSERT(!(STATE & SecurityOriginSet), property_securityOrigin_already_set);
            m_result->setString(ASCIILiteral("securityOrigin"), value);
            return castState<SecurityOriginSet>();
        }

        Builder<STATE | UrlSet>& setUrl(const String& value)
        {
            COMPILE_ASSERT(!(STATE & UrlSet), property_url_already_set);
            m_result->setString(ASCIILiteral("url"), value);
            return castState<UrlSet>();
        }

        Ref<InitializationInfo> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(InitializationInfo) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<InitializationInfo>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<InitializationInfo> result = InitializationInfo::create()
     *     .setTargetId(...)
     *     .setSecurityOrigin(...)
     *     .setUrl(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }
};

} // ServiceWorker

namespace Timeline {
/* Timeline record type. */
enum class EventType {
    EventDispatch = 138,
    ScheduleStyleRecalculation = 139,
    RecalculateStyles = 140,
    InvalidateLayout = 141,
    Layout = 142,
    Paint = 143,
    Composite = 144,
    RenderingFrame = 145,
    TimerInstall = 146,
    TimerRemove = 147,
    TimerFire = 148,
    EvaluateScript = 149,
    TimeStamp = 150,
    Time = 151,
    TimeEnd = 152,
    FunctionCall = 153,
    ProbeSample = 154,
    ConsoleProfile = 155,
    RequestAnimationFrame = 156,
    CancelAnimationFrame = 157,
    FireAnimationFrame = 158,
}; // enum class EventType
/* Instrument types. */
enum class Instrument {
    ScriptProfiler = 159,
    Timeline = 160,
    Memory = 161,
    Heap = 162,
}; // enum class Instrument
/* Timeline record contains information about the recorded activity. */
class TimelineEvent : public JSON::Object {
public:
    enum {
        NoFieldsSet = 0,
        TypeSet = 1 << 0,
        DataSet = 1 << 1,
        AllFieldsSet = (TypeSet | DataSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<JSON::Object> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*TimelineEvent*/JSON::Object>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class TimelineEvent;
    public:

        Builder<STATE | TypeSet>& setType(Inspector::Protocol::Timeline::EventType value)
        {
            COMPILE_ASSERT(!(STATE & TypeSet), property_type_already_set);
            m_result->setString(ASCIILiteral("type"), Inspector::Protocol::InspectorHelpers::getEnumConstantValue(value));
            return castState<TypeSet>();
        }

        Builder<STATE | DataSet>& setData(RefPtr<JSON::Object> value)
        {
            COMPILE_ASSERT(!(STATE & DataSet), property_data_already_set);
            m_result->setObject(ASCIILiteral("data"), value);
            return castState<DataSet>();
        }

        Ref<TimelineEvent> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(TimelineEvent) == sizeof(JSON::Object), cannot_cast);

            Ref<JSON::Object> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<TimelineEvent>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<TimelineEvent> result = TimelineEvent::create()
     *     .setType(...)
     *     .setData(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(JSON::Object::create());
    }

    void setChildren(RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Timeline::TimelineEvent>> value)
    {
        JSON::ObjectBase::setArray(ASCIILiteral("children"), WTFMove(value));
    }

    // Property names for type generated as open.
    JS_EXPORT_PRIVATE static const char* Type;
    JS_EXPORT_PRIVATE static const char* Data;
    JS_EXPORT_PRIVATE static const char* Children;
};

} // Timeline

template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Debugger::Location> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Debugger::FunctionDetails> {
static RefPtr<Inspector::Protocol::Debugger::FunctionDetails> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Debugger::CallFrame> {
static RefPtr<Inspector::Protocol::Debugger::CallFrame> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Debugger::Scope::Type> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Debugger::Scope> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::RemoteObject::Type> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::RemoteObject::Subtype> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::RemoteObject> {
static RefPtr<Inspector::Protocol::Runtime::RemoteObject> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::ObjectPreview::Type> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::ObjectPreview::Subtype> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::ObjectPreview> {
static RefPtr<Inspector::Protocol::Runtime::ObjectPreview> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::PropertyPreview::Type> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::PropertyPreview::Subtype> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::PropertyPreview> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::EntryPreview> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::CollectionEntry> {
static RefPtr<Inspector::Protocol::Runtime::CollectionEntry> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::PropertyDescriptor> {
static RefPtr<Inspector::Protocol::Runtime::PropertyDescriptor> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Runtime::InternalPropertyDescriptor> {
static RefPtr<Inspector::Protocol::Runtime::InternalPropertyDescriptor> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Timeline::EventType> {
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};
template<> struct JS_EXPORT_PRIVATE BindingTraits<Inspector::Protocol::Timeline::TimelineEvent> {
static RefPtr<Inspector::Protocol::Timeline::TimelineEvent> runtimeCast(RefPtr<JSON::Value>&& value);
#if !ASSERT_DISABLED
static void assertValueHasExpectedType(JSON::Value*);
#endif // !ASSERT_DISABLED
};

namespace InspectorHelpers {

template<typename ProtocolEnumType>
std::optional<ProtocolEnumType> parseEnumValueFromString(const String&);

// Enums in the 'CSS' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::CSS::StyleSheetOrigin> parseEnumValueFromString<Inspector::Protocol::CSS::StyleSheetOrigin>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::CSS::CSSPropertyStatus> parseEnumValueFromString<Inspector::Protocol::CSS::CSSPropertyStatus>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::CSS::CSSMedia::Source> parseEnumValueFromString<Inspector::Protocol::CSS::CSSMedia::Source>(const String&);

// Enums in the 'Canvas' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Canvas::ContextType> parseEnumValueFromString<Inspector::Protocol::Canvas::ContextType>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Canvas::ShaderType> parseEnumValueFromString<Inspector::Protocol::Canvas::ShaderType>(const String&);

// Enums in the 'Console' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Console::ChannelSource> parseEnumValueFromString<Inspector::Protocol::Console::ChannelSource>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Console::ChannelLevel> parseEnumValueFromString<Inspector::Protocol::Console::ChannelLevel>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Console::ConsoleMessage::Level> parseEnumValueFromString<Inspector::Protocol::Console::ConsoleMessage::Level>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Console::ConsoleMessage::Type> parseEnumValueFromString<Inspector::Protocol::Console::ConsoleMessage::Type>(const String&);

// Enums in the 'DOM' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::PseudoType> parseEnumValueFromString<Inspector::Protocol::DOM::PseudoType>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::ShadowRootType> parseEnumValueFromString<Inspector::Protocol::DOM::ShadowRootType>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::CustomElementState> parseEnumValueFromString<Inspector::Protocol::DOM::CustomElementState>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::LiveRegionRelevant> parseEnumValueFromString<Inspector::Protocol::DOM::LiveRegionRelevant>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::AccessibilityProperties::Checked> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::Checked>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::AccessibilityProperties::Current> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::Current>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::AccessibilityProperties::Invalid> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::Invalid>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus>(const String&);

// Enums in the 'DOMDebugger' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::DOMDebugger::DOMBreakpointType> parseEnumValueFromString<Inspector::Protocol::DOMDebugger::DOMBreakpointType>(const String&);

// Enums in the 'Debugger' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Debugger::BreakpointAction::Type> parseEnumValueFromString<Inspector::Protocol::Debugger::BreakpointAction::Type>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Debugger::Scope::Type> parseEnumValueFromString<Inspector::Protocol::Debugger::Scope::Type>(const String&);

// Enums in the 'Heap' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Heap::GarbageCollection::Type> parseEnumValueFromString<Inspector::Protocol::Heap::GarbageCollection::Type>(const String&);

#if ENABLE(INDEXED_DATABASE)
// Enums in the 'IndexedDB' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::IndexedDB::Key::Type> parseEnumValueFromString<Inspector::Protocol::IndexedDB::Key::Type>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::IndexedDB::KeyPath::Type> parseEnumValueFromString<Inspector::Protocol::IndexedDB::KeyPath::Type>(const String&);
#endif // ENABLE(INDEXED_DATABASE)

#if ENABLE(RESOURCE_USAGE)
// Enums in the 'Memory' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Memory::CategoryData::Type> parseEnumValueFromString<Inspector::Protocol::Memory::CategoryData::Type>(const String&);
#endif // ENABLE(RESOURCE_USAGE)

// Enums in the 'Network' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Network::Response::Source> parseEnumValueFromString<Inspector::Protocol::Network::Response::Source>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Network::Metrics::Priority> parseEnumValueFromString<Inspector::Protocol::Network::Metrics::Priority>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Network::Initiator::Type> parseEnumValueFromString<Inspector::Protocol::Network::Initiator::Type>(const String&);

// Enums in the 'Page' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Page::ResourceType> parseEnumValueFromString<Inspector::Protocol::Page::ResourceType>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Page::CoordinateSystem> parseEnumValueFromString<Inspector::Protocol::Page::CoordinateSystem>(const String&);

// Enums in the 'Recording' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Recording::Type> parseEnumValueFromString<Inspector::Protocol::Recording::Type>(const String&);

// Enums in the 'Runtime' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::SyntaxErrorType> parseEnumValueFromString<Inspector::Protocol::Runtime::SyntaxErrorType>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::RemoteObject::Type> parseEnumValueFromString<Inspector::Protocol::Runtime::RemoteObject::Type>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::RemoteObject::Subtype> parseEnumValueFromString<Inspector::Protocol::Runtime::RemoteObject::Subtype>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::ObjectPreview::Type> parseEnumValueFromString<Inspector::Protocol::Runtime::ObjectPreview::Type>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::ObjectPreview::Subtype> parseEnumValueFromString<Inspector::Protocol::Runtime::ObjectPreview::Subtype>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::PropertyPreview::Type> parseEnumValueFromString<Inspector::Protocol::Runtime::PropertyPreview::Type>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Runtime::PropertyPreview::Subtype> parseEnumValueFromString<Inspector::Protocol::Runtime::PropertyPreview::Subtype>(const String&);

// Enums in the 'ScriptProfiler' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::ScriptProfiler::EventType> parseEnumValueFromString<Inspector::Protocol::ScriptProfiler::EventType>(const String&);

// Enums in the 'Timeline' Domain
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Timeline::EventType> parseEnumValueFromString<Inspector::Protocol::Timeline::EventType>(const String&);
template<>
JS_EXPORT_PRIVATE std::optional<Inspector::Protocol::Timeline::Instrument> parseEnumValueFromString<Inspector::Protocol::Timeline::Instrument>(const String&);

} // namespace InspectorHelpers

} // namespace Protocol

} // namespace Inspector
